<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>방송통신대학교 컴퓨터과학과 시험 대비</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .subject-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .subject-card {
            background: linear-gradient(145deg, #f0f4f8, #d9e2ec);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
        }

        .subject-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            border-color: #667eea;
        }

        .subject-card h3 {
            color: #2d3748;
            margin-bottom: 10px;
            font-size: 1.3rem;
        }

        .subject-card p {
            color: #718096;
            font-size: 0.9rem;
            margin-bottom: 15px;
        }

        .subject-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #4a5568;
        }

        .btn {
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .btn-secondary {
            background: linear-gradient(145deg, #718096, #4a5568);
            box-shadow: 0 4px 15px rgba(113, 128, 150, 0.4);
        }

        .btn-danger {
            background: linear-gradient(145deg, #fc8181, #e53e3e);
            box-shadow: 0 4px 15px rgba(252, 129, 129, 0.4);
        }

        .question-container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e2e8f0;
        }

        .question-info {
            font-size: 1.1rem;
            color: #4a5568;
        }

        .timer {
            background: linear-gradient(145deg, #fc8181, #e53e3e);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        .question-text {
            font-size: 1.3rem;
            line-height: 1.6;
            margin-bottom: 25px;
            color: #2d3748;
        }

        .question-code {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            white-space: pre-wrap;
        }

        .options {
            display: grid;
            gap: 15px;
        }

        .option {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1rem;
        }

        .option:hover {
            border-color: #667eea;
            background: #edf2f7;
        }

        .option.selected {
            border-color: #667eea;
            background: linear-gradient(145deg, #ebf4ff, #bee3f8);
            color: #2b6cb0;
        }

        .option.correct {
            border-color: #48bb78;
            background: linear-gradient(145deg, #f0fff4, #c6f6d5);
            color: #22543d;
        }

        .option.incorrect {
            border-color: #f56565;
            background: linear-gradient(145deg, #fff5f5, #fed7d7);
            color: #742a2a;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
        }

        .result-card {
            text-align: center;
            padding: 40px;
        }

        .score-display {
            font-size: 4rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 20px;
        }

        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-item {
            background: linear-gradient(145deg, #f0f4f8, #d9e2ec);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #2d3748;
        }

        .stat-label {
            color: #718096;
            margin-top: 5px;
        }

        .wrong-answers {
            text-align: left;
            margin-top: 30px;
        }

        .wrong-question {
            background: #fff5f5;
            border-left: 4px solid #f56565;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            text-align: center;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .container {
                padding: 15px;
            }
            
            .card {
                padding: 20px;
            }
            
            .controls {
                flex-direction: column;
                gap: 15px;
            }
            
            .question-header {
                flex-direction: column;
                gap: 15px;
            }
        }

        .hidden {
            display: none;
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎓 방송통신대학교</h1>
            <p>컴퓨터과학과 시험 대비 시스템</p>
        </div>

        <!-- 메인 화면 -->
        <div id="mainScreen" class="fade-in">
            <div class="card">
                <h2 style="text-align: center; margin-bottom: 30px; color: #2d3748;">📚 과목 선택</h2>
                <div class="subject-grid">
                    <div class="subject-card" onclick="startExam('computer')">
                        <h3>💻 컴퓨터의이해</h3>
                        <p>5장~13장 (20문제)</p>
                        <div class="subject-stats">
                            <span>최고점수: <span id="computer-best">0</span>점</span>
                            <span>응시횟수: <span id="computer-count">0</span>회</span>
                        </div>
                    </div>
                    <div class="subject-card" onclick="startExam('ubiquitous')">
                        <h3>🌐 유비쿼터스컴퓨팅개론</h3>
                        <p>교재 전체 (20문제)</p>
                        <div class="subject-stats">
                            <span>최고점수: <span id="ubiquitous-best">0</span>점</span>
                            <span>응시횟수: <span id="ubiquitous-count">0</span>회</span>
                        </div>
                    </div>
                    <div class="subject-card" onclick="startExam('python')">
                        <h3>🐍 파이썬프로그래밍기초</h3>
                        <p>멀티미디어 강의 전체 (20문제)</p>
                        <div class="subject-stats">
                            <span>최고점수: <span id="python-best">0</span>점</span>
                            <span>응시횟수: <span id="python-count">0</span>회</span>
                        </div>
                    </div>
                    <div class="subject-card" onclick="startExam('html')">
                        <h3>🌍 HTML5웹프로그래밍</h3>
                        <p>1~7장, 강의 1~15강 (20문제)</p>
                        <div class="subject-stats">
                            <span>최고점수: <span id="html-best">0</span>점</span>
                            <span>응시횟수: <span id="html-count">0</span>회</span>
                        </div>
                    </div>
                    <div class="subject-card" onclick="startExam('java')">
                        <h3>☕ Java프로그래밍</h3>
                        <p>교재 전체 (20문제)</p>
                        <div class="subject-stats">
                            <span>최고점수: <span id="java-best">0</span>점</span>
                            <span>응시횟수: <span id="java-count">0</span>회</span>
                        </div>
                    </div>
                    <div class="subject-card" onclick="startExam('mixed')">
                        <h3>🎯 종합시험</h3>
                        <p>전 과목 랜덤 (20문제)</p>
                        <div class="subject-stats">
                            <span>최고점수: <span id="mixed-best">0</span>점</span>
                            <span>응시횟수: <span id="mixed-count">0</span>회</span>
                        </div>
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn btn-secondary" onclick="showWrongAnswers()">📝 오답노트 보기</button>
                    <button class="btn btn-danger" onclick="resetAllData()">🗑️ 데이터 초기화</button>
                </div>
            </div>
        </div>

        <!-- 시험 화면 -->
        <div id="examScreen" class="hidden">
            <div class="question-container">
                <div class="question-header">
                    <div class="question-info">
                        <span id="currentSubject"></span> | 
                        문제 <span id="currentQuestionNum">1</span> / <span id="totalQuestions">20</span>
                    </div>
                    <div class="timer" id="timer">30:00</div>
                </div>
                
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                
                <div class="question-text" id="questionText"></div>
                <div class="question-code" id="questionCode" style="display: none;"></div>
                <div class="options" id="optionsContainer"></div>
                
                <div class="controls">
                    <button class="btn btn-secondary" onclick="previousQuestion()">◀ 이전</button>
                    <button class="btn" id="nextBtn" onclick="nextQuestion()">다음 ▶</button>
                    <button class="btn btn-danger" onclick="finishExam()">시험 종료</button>
                </div>
            </div>
        </div>

        <!-- 결과 화면 -->
        <div id="resultScreen" class="hidden">
            <div class="card result-card">
                <h2>🎉 시험 완료!</h2>
                <div class="score-display" id="finalScore">0점</div>
                
                <div class="result-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="correctCount">0</div>
                        <div class="stat-label">정답</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="incorrectCount">0</div>
                        <div class="stat-label">오답</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="accuracy">0%</div>
                        <div class="stat-label">정답률</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="timeUsed">0분</div>
                        <div class="stat-label">소요시간</div>
                    </div>
                </div>

                <div class="wrong-answers" id="wrongAnswersContainer" style="display: none;">
                    <h3>❌ 틀린 문제들</h3>
                    <div id="wrongQuestionsList"></div>
                </div>

                <div style="margin-top: 30px;">
                    <button class="btn" onclick="restartExam()">🔄 다시 시험</button>
                    <button class="btn btn-secondary" onclick="reviewWrongAnswers()">📖 틀린 문제 복습</button>
                    <button class="btn btn-secondary" onclick="goHome()">🏠 홈으로</button>
                </div>
            </div>
        </div>

        <!-- 오답노트 화면 -->
        <div id="wrongAnswerScreen" class="hidden">
            <div class="card">
                <h2>📝 오답노트</h2>
                <div id="wrongAnswersList"></div>
                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn btn-secondary" onclick="goHome()">🏠 홈으로</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 확인 모달 -->
    <div id="confirmModal" class="modal">
        <div class="modal-content">
            <h3 id="modalTitle">확인</h3>
            <p id="modalMessage">정말로 실행하시겠습니까?</p>
            <div style="margin-top: 20px;">
                <button class="btn" onclick="confirmAction()">확인</button>
                <button class="btn btn-secondary" onclick="closeModal()" style="margin-left: 10px;">취소</button>
            </div>
        </div>
    </div>

    <script>
        // 전역 변수
        let currentSubject = '';
        let currentQuestions = [];
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let examStartTime = 0;
        let examTimer = null;
        let examTimeLimit = 30 * 60; // 30분
        let examTimeLeft = examTimeLimit;
        let confirmCallback = null;

        // 통계 데이터 (메모리 저장)
        let examStats = {
            computer: { best: 0, count: 0 },
            ubiquitous: { best: 0, count: 0 },
            python: { best: 0, count: 0 },
            html: { best: 0, count: 0 },
            java: { best: 0, count: 0 },
            mixed: { best: 0, count: 0 }
        };

        let wrongAnswersHistory = [];

        // 문제 데이터베이스
        const questionDatabase = {
            computer: [
                {
                    question: "컴퓨터의 중앙처리장치(CPU)에 대한 설명으로 올바른 것은?",
                    options: [
                        "CPU는 주로 데이터를 영구적으로 저장하는 역할을 담당한다",
                        "제어장치와 연산장치로 구성되어 있다",
                        "보조기억장치의 일종이다",
                        "입력된 데이터를 화면에 출력하는 역할을 한다"
                    ],
                    correct: 1,
                    explanation: "CPU는 제어장치(Control Unit)와 연산장치(ALU)로 구성되어 있습니다."
                },
                {
                    question: "다음 중 입력장치가 아닌 것은?",
                    options: ["키보드", "마우스", "스피커", "터치패드"],
                    correct: 2,
                    explanation: "스피커는 소리를 출력하는 출력장치입니다."
                },
                {
                    question: "주기억장치(RAM)의 특징으로 올바른 것은?",
                    options: [
                        "전원이 꺼져도 데이터가 보존된다",
                        "보조기억장치보다 용량이 크다",
                        "휘발성 메모리이다",
                        "순차접근 방식으로 데이터를 읽는다"
                    ],
                    correct: 2,
                    explanation: "RAM은 전원이 꺼지면 데이터가 사라지는 휘발성 메모리입니다."
                },
                {
                    question: "다음 중 보조기억장치에 해당하는 것은?",
                    options: ["RAM", "ROM", "캐시메모리", "하드디스크"],
                    correct: 3,
                    explanation: "하드디스크는 데이터를 영구적으로 저장하는 보조기억장치입니다."
                },
                {
                    question: "QR코드에 대한 설명으로 틀린 것은?",
                    options: [
                        "2차원 바코드의 일종이다",
                        "Quick Response의 줄임말이다",
                        "1차원 바코드보다 적은 정보를 저장한다",
                        "스마트폰으로 쉽게 읽을 수 있다"
                    ],
                    correct: 2,
                    explanation: "QR코드는 1차원 바코드보다 훨씬 많은 정보를 저장할 수 있습니다."
                },
                {
                    question: "컴퓨터 네트워크의 종류 중 가장 넓은 범위를 갖는 것은?",
                    options: ["LAN", "MAN", "WAN", "PAN"],
                    correct: 2,
                    explanation: "WAN(Wide Area Network)은 가장 넓은 지역을 연결하는 네트워크입니다."
                },
                {
                    question: "인터넷 프로토콜 중 웹페이지 전송에 주로 사용되는 것은?",
                    options: ["FTP", "HTTP", "SMTP", "POP3"],
                    correct: 1,
                    explanation: "HTTP(HyperText Transfer Protocol)는 웹페이지 전송을 위한 프로토콜입니다."
                },
                {
                    question: "다음 중 시스템 소프트웨어에 해당하는 것은?",
                    options: ["워드프로세서", "웹브라우저", "운영체제", "게임"],
                    correct: 2,
                    explanation: "운영체제는 컴퓨터 시스템을 관리하는 시스템 소프트웨어입니다."
                },
                {
                    question: "데이터베이스 관리시스템(DBMS)의 주요 기능이 아닌 것은?",
                    options: ["데이터 정의", "데이터 조작", "데이터 제어", "데이터 압축"],
                    correct: 3,
                    explanation: "DBMS의 주요 기능은 데이터 정의, 조작, 제어이며, 압축은 부가 기능입니다."
                },
                {
                    question: "컴퓨터 바이러스에 대한 설명으로 틀린 것은?",
                    options: [
                        "자기복제 능력을 갖는다",
                        "다른 프로그램에 기생한다",
                        "하드웨어만 감염시킨다",
                        "예방을 위해 백신 프로그램을 사용한다"
                    ],
                    correct: 2,
                    explanation: "컴퓨터 바이러스는 소프트웨어를 감염시키며, 하드웨어를 직접 감염시키지는 않습니다."
                },
                {
                    question: "하드디스크는 주기억장치에 속한다.",
                    type: "ox",
                    correct: false,
                    explanation: "하드디스크는 보조기억장치입니다."
                },
                {
                    question: "URL은 Uniform Resource Locator의 줄임말이다.",
                    type: "ox",
                    correct: true,
                    explanation: "URL은 Uniform Resource Locator의 줄임말이 맞습니다."
                },
                {
                    question: "컴파일러는 고급언어를 기계어로 번역하는 프로그램이다.",
                    type: "ox",
                    correct: true,
                    explanation: "컴파일러는 고급언어를 기계어로 번역하는 번역 프로그램입니다."
                },
                {
                    question: "TCP/IP는 인터넷의 표준 프로토콜이다.",
                    type: "ox",
                    correct: true,
                    explanation: "TCP/IP는 인터넷에서 사용되는 표준 통신 프로토콜입니다."
                },
                {
                    question: "폰 노이만 구조에서는 프로그램과 데이터가 같은 메모리에 저장된다.",
                    type: "ox",
                    correct: true,
                    explanation: "폰 노이만 구조의 특징은 프로그램과 데이터가 동일한 메모리에 저장되는 것입니다."
                },
                {
                    question: "클라우드 컴퓨팅의 특징으로 올바른 것은?",
                    options: [
                        "개인 컴퓨터에만 데이터를 저장한다",
                        "인터넷을 통해 컴퓨팅 자원을 제공받는다",
                        "오프라인에서만 사용 가능하다",
                        "하드웨어 구매가 필수적이다"
                    ],
                    correct: 1,
                    explanation: "클라우드 컴퓨팅은 인터넷을 통해 컴퓨팅 자원을 서비스로 제공받는 기술입니다."
                },
                {
                    question: "정보보안의 3요소가 아닌 것은?",
                    options: ["기밀성(Confidentiality)", "무결성(Integrity)", "가용성(Availability)", "호환성(Compatibility)"],
                    correct: 3,
                    explanation: "정보보안의 3요소는 기밀성, 무결성, 가용성입니다."
                },
                {
                    question: "멀티미디어 데이터 중 용량이 가장 큰 것은?",
                    options: ["텍스트", "이미지", "오디오", "비디오"],
                    correct: 3,
                    explanation: "비디오는 이미지와 오디오를 포함하므로 가장 큰 용량을 차지합니다."
                },
                {
                    question: "다음 중 프로그래밍 언어가 아닌 것은?",
                    options: ["Java", "Python", "HTML", "C++"],
                    correct: 2,
                    explanation: "HTML은 마크업 언어이며, 프로그래밍 언어가 아닙니다."
                },
                {
                    question: "인공지능(AI)의 분야가 아닌 것은?",
                    options: ["기계학습", "자연어처리", "컴퓨터비전", "하드웨어설계"],
                    correct: 3,
                    explanation: "하드웨어설계는 인공지능의 연구 분야가 아닙니다."
                }
            ],
            ubiquitous: [
                {
                    question: "유비쿼터스 혁명이 만들어내는 공간으로 옳은 것은?",
                    options: ["유비쿼터스 공간", "사이버 공간", "물리공간", "가상 공간"],
                    correct: 0,
                    explanation: "유비쿼터스 혁명은 물리공간과 사이버공간이 융합된 유비쿼터스 공간을 만들어냅니다."
                },
                {
                    question: "유비쿼터스 컴퓨팅의 특징이 아닌 것은?",
                    options: [
                        "사물내의 컴퓨터의 내재화",
                        "사람-사물-컴퓨터 유기적 연결",
                        "모든 사물의 지능화",
                        "가상공간과 사이버공간의 융합"
                    ],
                    correct: 3,
                    explanation: "유비쿼터스 컴퓨팅은 물리공간과 사이버공간의 융합이 특징입니다."
                },
                {
                    question: "MEMS 기술의 특징인 것은?",
                    options: ["단편적 기술", "단일 산업 분야와의 연계", "부품의 평면성", "기술의 융합성"],
                    correct: 3,
                    explanation: "MEMS는 기계, 전자, 재료 등 여러 기술이 융합된 기술입니다."
                },
                {
                    question: "디지털 콘텐츠의 불법복제에 따른 문제를 해결하고 저작권자의 권리를 보호하기 위해서 제안된 기술은?",
                    options: ["RFID", "DRM", "HCI 기술", "생체인식 기술"],
                    correct: 1,
                    explanation: "DRM(Digital Rights Management)은 디지털 저작권 관리 기술입니다."
                },
                {
                    question: "사람의 기본적인 의사소통 수단인 '말(언어)'을 통해 보다 편리하고 인간적인 방식의 컴퓨팅 환경을 구축하기 위한 기반 기술은?",
                    options: ["음성인식 기술", "홍채인식 기술", "음성합성 기술", "안면인식 기술"],
                    correct: 0,
                    explanation: "음성인식 기술은 사람의 음성을 컴퓨터가 이해할 수 있도록 하는 기술입니다."
                },
                {
                    question: "RFID 시스템 구성 요소에 포함되지 않는 것은?",
                    options: [
                        "무선 송수신용 안테나를 내장한 리더(Reader)",
                        "필요한 정보를 저장하고 교환하는 태그",
                        "무선 충전기술",
                        "유․무선 통신망으로 연결된 서버"
                    ],
                    correct: 2,
                    explanation: "RFID 시스템은 리더, 태그, 통신망으로 구성되며 무선 충전기술은 포함되지 않습니다."
                },
                {
                    question: "칩 자체가 하나의 시스템으로 기능할 수 있도록 마이크로 프로세서와 디지털 신호 처리 장치, 메모리, 베이스밴드 칩, 임베디드 소프트웨어 등을 집적시킨 칩은?",
                    options: ["RFID", "ZigBee", "NFC", "SoC (system on chip)"],
                    correct: 3,
                    explanation: "SoC는 하나의 칩에 시스템 전체 기능을 집적한 기술입니다."
                },
                {
                    question: "IoT 플랫폼이 갖추어야 할 기능이 아닌 것은?",
                    options: [
                        "이기종 센서들에 대한 식별 및 연결 기능",
                        "각 사물에 대한 제어 기능",
                        "웹을 통한 폐쇄형 서비스 제공 기능",
                        "수집된 대용량 데이터에 대한 효율적인 검색 및 분석 기능"
                    ],
                    correct: 2,
                    explanation: "IoT 플랫폼은 개방형 서비스를 제공해야 하며, 폐쇄형은 적합하지 않습니다."
                },
                {
                    question: "다음 중 충전이 아닌 연료를 공급함으로써 지속적인 전기 생산이 가능한 전지는?",
                    options: ["납축전지", "태양전지", "연료전지", "대용량 커패시터"],
                    correct: 2,
                    explanation: "연료전지는 수소와 산소의 화학반응으로 지속적으로 전기를 생산합니다."
                },
                {
                    question: "유비쿼터스 네트워크에서 서버상의 콘텐츠 같은 객체로 연결성 제공 및 서비스를 위한 객체는?",
                    options: ["환경 사물", "고정 사물", "이동 사물", "논리적 사물"],
                    correct: 3,
                    explanation: "논리적 사물은 소프트웨어적으로 구현된 가상의 객체를 말합니다."
                },
                {
                    question: "다음 중 RFID의 특징이 아닌 것은?",
                    options: [
                        "데이터의 위조 및 변조가 불가능하다",
                        "바코드에 비해 가격이 높다",
                        "바코드에 비해 많은 정보의 축적이 가능하다",
                        "바코드나 스마트카드에 비해서 활용 범위나 적용 분야가 좁다"
                    ],
                    correct: 3,
                    explanation: "RFID는 바코드보다 활용 범위와 적용 분야가 넓습니다."
                },
                {
                    question: "유비쿼터스 센서 네트워크의 계층구조에 포함되지 않는 것은?",
                    options: [
                        "USN 응용 서비스 계층",
                        "USN 미들웨어 계층",
                        "BcN 백본 및 접속 네트워크 계층",
                        "센서 연결 계층"
                    ],
                    correct: 3,
                    explanation: "USN 계층구조에는 응용 서비스, 미들웨어, 백본 네트워크 계층이 포함됩니다."
                },
                {
                    question: "센서 네트워크 내의 모든 센서 노드에서 센싱된 데이터를 수집하는 노드는?",
                    options: ["싱크노드", "단말노드", "센서노드", "루트노드"],
                    correct: 0,
                    explanation: "싱크노드는 센서 네트워크에서 데이터를 수집하는 중앙 노드입니다."
                },
                {
                    question: "RFID에서 정보보호 방안중에서 금속성의 그물(mesh)이나 박막(foil)을 입혀 무선 주파수가 침투하지 못하도록 하는 것은?",
                    options: [
                        "킬 태그(Kill Tag)",
                        "페러데이 케이지(Faraday Cage)",
                        "방해 전파(Active Jamming)",
                        "차단자 태그(Blocker Tag)"
                    ],
                    correct: 1,
                    explanation: "페러데이 케이지는 전자기파를 차단하는 금속 울타리 구조입니다."
                },
                {
                    question: "상황 인식 시스템에서 상황정보 모델링 방법중에서 태그, 속성 그리고 내용을 계층구조로 나타내어 재귀적 형태로 상황정보를 표현하는 것은?",
                    options: [
                        "온톨로지 기반 모델",
                        "마크 업 기반 모델",
                        "키값 기반 모델",
                        "인덱스 기반 모델"
                    ],
                    correct: 1,
                    explanation: "마크업 기반 모델은 XML과 같은 태그 구조로 정보를 표현합니다."
                },
                {
                    question: "컴퓨터가 사람의 일상 언어를 이해하고 생성할 수 있도록 함으로써 인간의 지적 활동의 보조자 및 지원 도구로 활용하고자 하는 기술은?",
                    options: [
                        "음성 합성 기술",
                        "자연어 처리 기술",
                        "음성 분석 기술",
                        "정보 처리 기술"
                    ],
                    correct: 1,
                    explanation: "자연어 처리 기술은 컴퓨터가 인간의 언어를 이해하고 처리하는 기술입니다."
                },
                {
                    question: "착용 컴퓨팅 기술의 기본 기능이 아닌 것은?",
                    options: ["착용감", "항시성", "정숙성", "안정성"],
                    correct: 2,
                    explanation: "착용 컴퓨팅의 기본 기능은 착용감, 항시성, 안정성입니다."
                },
                {
                    question: "u-시티의 특성이 아닌 것은?",
                    options: [
                        "정보중심의 도시",
                        "효율적 도시관리 기능",
                        "인구, 교통, 업무의 중앙화",
                        "자급자족의 친환경 도시"
                    ],
                    correct: 2,
                    explanation: "u-시티는 분산화된 도시 구조를 지향합니다."
                },
                {
                    question: "u-시티 네트워크를 활용하여 u-시티의 각종 스마트 시설 및 u-시티 서비스를 실시간으로 관리 및 제어하는 기능을 수행하는 것은?",
                    options: [
                        "u-시티 통합 단말기",
                        "u-시티 네트워크",
                        "u-시티 서비스 플랫폼",
                        "u-시티 운영센터"
                    ],
                    correct: 3,
                    explanation: "u-시티 운영센터는 도시 전체를 통합 관리하는 중앙 시설입니다."
                },
                {
                    question: "유비쿼터스 컴퓨팅의 특징으로 올바른 것은?",
                    options: [
                        "컴퓨터가 항상 눈에 보이는 곳에 위치한다",
                        "언제 어디서나 네트워크에 접속할 수 있다",
                        "한 번에 하나의 작업만 처리할 수 있다",
                        "사용자가 직접 컴퓨터를 조작해야만 동작한다"
                    ],
                    correct: 1,
                    explanation: "유비쿼터스 컴퓨팅은 언제 어디서나 접근 가능한 컴퓨팅 환경을 의미합니다."
                },
                {
                    question: "IoT(Internet of Things)에 대한 설명으로 틀린 것은?",
                    options: [
                        "사물인터넷이라고도 한다",
                        "다양한 사물들이 인터넷에 연결되어 정보를 주고받는다",
                        "센서와 통신 기능이 필요하다",
                        "인터넷 없이도 완전히 독립적으로 동작한다"
                    ],
                    correct: 3,
                    explanation: "IoT는 인터넷을 통해 사물들이 연결되어 정보를 주고받는 기술입니다."
                },
                {
                    question: "스마트홈의 구성요소가 아닌 것은?",
                    options: ["센서", "홈 게이트웨이", "스마트 가전제품", "진공관"],
                    correct: 3,
                    explanation: "진공관은 스마트홈과 관련이 없는 구식 전자부품입니다."
                },
                {
                    question: "RFID 시스템의 구성요소가 아닌 것은?",
                    options: ["RFID 태그", "RFID 리더", "안테나", "모니터"],
                    correct: 3,
                    explanation: "RFID 시스템은 태그, 리더, 안테나로 구성되며 모니터는 필수 구성요소가 아닙니다."
                },
                {
                    question: "센서네트워크의 특징으로 틀린 것은?",
                    options: [
                        "무선 통신을 사용한다",
                        "배터리로 동작하는 경우가 많다",
                        "대용량 데이터 처리에 최적화되어 있다",
                        "환경 모니터링에 활용된다"
                    ],
                    correct: 2,
                    explanation: "센서네트워크는 저전력 환경에서 동작하므로 대용량 데이터 처리에는 최적화되어 있지 않습니다."
                },
                {
                    question: "모바일 컴퓨팅의 특징이 아닌 것은?",
                    options: ["이동성", "휴대성", "무선 연결성", "고정성"],
                    correct: 3,
                    explanation: "모바일 컴퓨팅의 특징은 이동성, 휴대성, 무선 연결성이며 고정성은 반대 개념입니다."
                },
                {
                    question: "위치기반 서비스(LBS)에서 사용되는 기술이 아닌 것은?",
                    options: ["GPS", "WiFi", "블루투스", "적외선 통신"],
                    correct: 3,
                    explanation: "LBS에서는 GPS, WiFi, 블루투스 등이 사용되며 적외선 통신은 거리 제한이 있어 부적합합니다."
                },
                {
                    question: "웨어러블 컴퓨팅 기기의 예가 아닌 것은?",
                    options: ["스마트워치", "스마트글래스", "피트니스 밴드", "데스크톱 컴퓨터"],
                    correct: 3,
                    explanation: "데스크톱 컴퓨터는 착용할 수 없는 고정형 컴퓨터입니다."
                },
                {
                    question: "상황인식 컴퓨팅에서 고려되는 컨텍스트가 아닌 것은?",
                    options: ["위치", "시간", "사용자 신원", "컴퓨터 브랜드"],
                    correct: 3,
                    explanation: "상황인식 컴퓨팅에서는 위치, 시간, 사용자 정보 등이 중요하며 브랜드는 관련 없습니다."
                },
                {
                    question: "스마트 시티의 구성요소가 아닌 것은?",
                    options: ["지능형 교통 시스템", "스마트 그리드", "u-헬스케어", "수동 관리 시스템"],
                    correct: 3,
                    explanation: "스마트 시티는 지능형 시스템들로 구성되며 수동 관리 시스템은 스마트 시티의 개념에 맞지 않습니다."
                },
                {
                    question: "유비쿼터스 컴퓨팅에서는 컴퓨터가 사용자에게 보이지 않게 숨겨져 있다.",
                    type: "ox",
                    correct: true,
                    explanation: "유비쿼터스의 특징 중 하나는 컴퓨터가 환경에 자연스럽게 숨겨져 있는 것입니다."
                },
                {
                    question: "RFID는 Radio Frequency Identification의 줄임말이다.",
                    type: "ox",
                    correct: true,
                    explanation: "RFID는 Radio Frequency Identification의 줄임말이 맞습니다."
                },
                {
                    question: "NFC는 근거리 무선 통신 기술이다.",
                    type: "ox",
                    correct: true,
                    explanation: "NFC(Near Field Communication)는 근거리 무선 통신 기술입니다."
                },
                {
                    question: "유비쿼터스 환경에서는 개인정보 보호 문제가 발생하지 않는다.",
                    type: "ox",
                    correct: false,
                    explanation: "유비쿼터스 환경에서는 오히려 개인정보 보호 문제가 더욱 중요해집니다."
                },
                {
                    question: "스마트폰은 유비쿼터스 컴퓨팅의 대표적인 사례이다.",
                    type: "ox",
                    correct: true,
                    explanation: "스마트폰은 언제 어디서나 사용할 수 있는 유비쿼터스 컴퓨팅의 대표적인 사례입니다."
                },
                {
                    question: "M2M(Machine to Machine) 통신의 특징으로 올바른 것은?",
                    options: [
                        "사람의 개입이 반드시 필요하다",
                        "기계 간 자동 통신이다",
                        "유선 통신만 사용한다",
                        "실시간 처리가 불가능하다"
                    ],
                    correct: 1,
                    explanation: "M2M은 기계와 기계 간의 자동 통신을 의미합니다."
                },
                {
                    question: "클라우드 컴퓨팅 서비스 모델이 아닌 것은?",
                    options: ["SaaS", "PaaS", "IaaS", "HaaS"],
                    correct: 3,
                    explanation: "클라우드 서비스 모델은 SaaS, PaaS, IaaS이며 HaaS는 표준 모델이 아닙니다."
                },
                {
                    question: "빅데이터의 특징을 나타내는 3V가 아닌 것은?",
                    options: ["Volume (크기)", "Velocity (속도)", "Variety (다양성)", "Vision (비전)"],
                    correct: 3,
                    explanation: "빅데이터의 3V는 Volume, Velocity, Variety입니다."
                },
                {
                    question: "증강현실(AR)과 가상현실(VR)의 차이점으로 올바른 것은?",
                    options: [
                        "AR은 현실 세계에 가상 정보를 합성한다",
                        "VR은 현실 세계를 완전히 대체한다",
                        "AR은 완전 몰입형 환경을 제공한다",
                        "①, ②번 모두 올바르다"
                    ],
                    correct: 3,
                    explanation: "AR은 현실에 가상 정보를 합성하고, VR은 현실을 완전히 대체합니다."
                },
                {
                    question: "스마트 그리드의 특징이 아닌 것은?",
                    options: ["양방향 통신", "지능형 전력망", "단방향 전력 공급", "신재생 에너지 통합"],
                    correct: 2,
                    explanation: "스마트 그리드는 양방향 통신과 지능형 제어가 특징입니다."
                }
            ],
            python: [
                {
                    question: "파이썬에서 변수를 선언할 때 올바른 방법은?",
                    options: ["int x = 10;", "var x = 10", "x = 10", "declare x = 10"],
                    correct: 2,
                    explanation: "파이썬에서는 변수명 = 값 형태로 간단히 선언합니다."
                },
                {
                    question: "다음 중 파이썬의 기본 데이터 타입이 아닌 것은?",
                    options: ["int", "float", "bool", "char"],
                    correct: 3,
                    explanation: "파이썬에는 char 타입이 없으며, 문자는 길이가 1인 문자열로 처리합니다."
                },
                {
                    question: "파이썬에서 리스트의 첫 번째 요소를 가져오는 방법은?",
                    options: ["list[1]", "list[0]", "list.first()", "list.get(1)"],
                    correct: 1,
                    explanation: "파이썬의 인덱스는 0부터 시작하므로 list[0]으로 첫 번째 요소에 접근합니다."
                },
                {
                    question: "다음 코드의 실행 결과는?\n```python\nx = [1, 2, 3, 4, 5]\nprint(len(x))\n```",
                    options: ["4", "5", "6", "오류 발생"],
                    correct: 1,
                    explanation: "len() 함수는 리스트의 요소 개수를 반환하므로 5가 출력됩니다."
                },
                {
                    question: "파이썬에서 문자열을 나타내는 방법이 아닌 것은?",
                    options: ["\"Hello\"", "'Hello'", "\"\"\"Hello\"\"\"", "<Hello>"],
                    correct: 3,
                    explanation: "파이썬에서는 <> 기호로 문자열을 나타낼 수 없습니다."
                },
                {
                    question: "다음 중 파이썬의 반복문이 아닌 것은?",
                    options: ["for", "while", "do-while", "①, ②번 모두 반복문이다"],
                    correct: 2,
                    explanation: "파이썬에는 do-while 반복문이 없습니다."
                },
                {
                    question: "파이썬에서 주석을 작성하는 방법은?",
                    options: ["// 주석", "/* 주석 */", "# 주석", "<!-- 주석 -->"],
                    correct: 2,
                    explanation: "파이썬에서는 # 기호를 사용하여 주석을 작성합니다."
                },
                {
                    question: "다음 코드의 실행 결과는?\n```python\nx = 10\ny = 3\nprint(x // y)\n```",
                    options: ["3.33", "3", "4", "1"],
                    correct: 1,
                    explanation: "// 연산자는 정수 나눗셈(몫)을 수행하므로 3이 출력됩니다."
                },
                {
                    question: "파이썬에서 함수를 정의할 때 사용하는 키워드는?",
                    options: ["function", "def", "func", "define"],
                    correct: 1,
                    explanation: "파이썬에서는 def 키워드를 사용하여 함수를 정의합니다."
                },
                {
                    question: "다음 코드의 실행 결과는?\n```python\ntext = \"Python\"\nprint(text[1:4])\n```",
                    options: ["Pyt", "yth", "ytho", "thon"],
                    correct: 1,
                    explanation: "문자열 슬라이싱에서 text[1:4]는 인덱스 1부터 3까지(4 미포함)를 의미하므로 'yth'가 출력됩니다."
                },
                {
                    question: "파이썬에서 들여쓰기(indentation)는 코드 블록을 구분하는 데 사용된다.",
                    type: "ox",
                    correct: true,
                    explanation: "파이썬은 들여쓰기로 코드 블록을 구분하는 언어입니다."
                },
                {
                    question: "파이썬은 컴파일 언어이다.",
                    type: "ox",
                    correct: false,
                    explanation: "파이썬은 인터프리터 언어입니다."
                },
                {
                    question: "파이썬에서 변수명은 숫자로 시작할 수 있다.",
                    type: "ox",
                    correct: false,
                    explanation: "파이썬 변수명은 숫자로 시작할 수 없습니다."
                },
                {
                    question: "파이썬은 객체지향 프로그래밍을 지원한다.",
                    type: "ox",
                    correct: true,
                    explanation: "파이썬은 객체지향 프로그래밍을 완전히 지원합니다."
                },
                {
                    question: "파이썬에서 리스트는 서로 다른 데이터 타입의 요소를 포함할 수 있다.",
                    type: "ox",
                    correct: true,
                    explanation: "파이썬 리스트는 서로 다른 데이터 타입의 요소를 포함할 수 있습니다."
                },
                {
                    question: "파이썬에서 딕셔너리를 생성하는 올바른 방법은?",
                    options: ["dict = [key: value]", "dict = {key: value}", "dict = (key: value)", "dict = <key: value>"],
                    correct: 1,
                    explanation: "파이썬에서 딕셔너리는 중괄호 {}를 사용하여 생성합니다."
                },
                {
                    question: "다음 중 파이썬의 조건문에서 사용되지 않는 키워드는?",
                    options: ["if", "elif", "else", "switch"],
                    correct: 3,
                    explanation: "파이썬에는 switch 문이 없습니다."
                },
                {
                    question: "파이썬에서 모듈을 import하는 올바른 방법은?",
                    options: ["include math", "import math", "using math", "require math"],
                    correct: 1,
                    explanation: "파이썬에서는 import 키워드를 사용하여 모듈을 가져옵니다."
                },
                {
                    question: "다음 코드의 실행 결과는?\n```python\nnumbers = [1, 2, 3]\nnumbers.append(4)\nprint(numbers)\n```",
                    options: ["[1, 2, 3]", "[1, 2, 3, 4]", "[4, 1, 2, 3]", "오류 발생"],
                    correct: 1,
                    explanation: "append() 메소드는 리스트의 끝에 요소를 추가합니다."
                },
                {
                    question: "파이썬에서 예외처리에 사용되는 키워드 조합으로 올바른 것은?",
                    options: ["try-catch", "try-except", "begin-rescue", "attempt-handle"],
                    correct: 1,
                    explanation: "파이썬에서는 try-except 구문을 사용하여 예외를 처리합니다."
                }
                ,
                // 기존 python 문제 배열에 추가할 내용들:
                {
                    question: "어떤 문제(라면끓이기)를 해결하기 위한 절차를 무엇이라고 하는가?",
                    options: ["프로그래밍 언어", "레시피", "컴파일러 또는 인터프리터", "알고리즘"],
                    correct: 3,
                    explanation: "알고리즘은 문제를 해결하기 위한 단계적인 절차나 방법입니다."
                },
                {
                    question: "'전공'이라는 설명은 어떤 유형의 데이터에 속하는가?",
                    options: ["연속적 데이터", "범주적 데이터", "정보", "반정형 데이터"],
                    correct: 1,
                    explanation: "전공은 분류나 범주를 나타내는 범주적 데이터입니다."
                },
                {
                    question: "표현의 모호성을 제거하고 자연어와 유사한 형태의 문법을 갖는 프로그래밍 언어는?",
                    options: ["1세대 프로그래밍 언어", "2세대 프로그래밍 언어", "3세대 프로그래밍 언어", "4세대 프로그래밍 언어"],
                    correct: 2,
                    explanation: "3세대 프로그래밍 언어는 자연어와 유사한 고급 언어입니다."
                },
                {
                    question: "폰 노이만 구조에 기반한 컴퓨터의 구성요소에 포함되지 않는 것은?",
                    options: ["입력장치", "출력장치", "기억장치", "판단장치"],
                    correct: 3,
                    explanation: "폰 노이만 구조는 입력장치, 출력장치, 기억장치, 제어장치, 연산장치로 구성됩니다."
                },
                {
                    question: "안경 또는 헬멧과 같은 장치를 머리에 착용하여 현실 세계와는 차단된 가상현실을 제공하는 장치는?",
                    options: ["HMD", "HUD", "SSD", "ROM"],
                    correct: 0,
                    explanation: "HMD(Head Mounted Display)는 머리에 착용하는 가상현실 장치입니다."
                },
                {
                    question: "부가적인 기능을 제공하여 사용자가 컴퓨터를 효율적이고 편리하게 관리할 수 있도록 지원해주는 소프트웨어는?",
                    options: ["운영체제", "유틸리티", "커널", "컴파일러"],
                    correct: 1,
                    explanation: "유틸리티는 컴퓨터 관리를 위한 보조 소프트웨어입니다."
                },
                {
                    question: "다음 중 파이썬의 장점이라고 할 수 없는 것은?",
                    options: ["뛰어난 생산성", "빠른 실행 속도", "대형 개발자 커뮤니티", "직관적 문법"],
                    correct: 1,
                    explanation: "파이썬은 인터프리터 언어로 컴파일 언어에 비해 실행 속도가 느린 편입니다."
                },
                {
                    question: "파이썬 프로그램이 플랫폼 독립적으로 실행될 수 있도록 파이썬 인터프리터가 중간 언어로 만드는 것은?",
                    options: ["바이트 코드", "어셈블러 코드", "파이썬 소스 코드", "기계어 코드"],
                    correct: 0,
                    explanation: "파이썬은 소스 코드를 바이트 코드로 컴파일한 후 가상머신에서 실행됩니다."
                },
                {
                    question: "오픈소스이며 웹 기반 대화형 개발 및 실행 환경을 제공하는 파이썬 프로그래밍 환경은?",
                    options: ["IDLE", "VS Code", "주피터 노트북", "코랩"],
                    correct: 2,
                    explanation: "주피터 노트북은 웹 기반 대화형 파이썬 개발 환경입니다."
                },
                {
                    question: "다음 중 식별자로 사용할 수 없는 것은?",
                    options: ["_pythonic", "graudate130", "270mm", "부피"],
                    correct: 2,
                    explanation: "식별자는 숫자로 시작할 수 없습니다."
                },
                {
                    question: "특정 영역 내의 명령문에 대한 실행 여부를 프로그램 실행 과정 중 조건에 따라 결정하는 구조는?",
                    options: ["선택 구조", "반복 구조", "순차 구조", "명령 구조"],
                    correct: 0,
                    explanation: "선택 구조는 조건에 따라 실행 여부를 결정하는 제어 구조입니다."
                },
                {
                    question: "파이썬에서 변수와 문자열을 연결하여 출력할 때 올바른 print 함수 사용법은?",
                    options: [
                        'print("상자에", "사과가", number, "개", "들어있습니다.")',
                        'print("상자에사과가number개들어있습니다.")',
                        'print("상자에", "사과가", number, "개", "들어있습니다.", end="")',
                        'print("상자에", "사과가", number, "개", "들어있습니다.", sep="")'
                    ],
                    correct: 3,
                    explanation: "sep=''를 사용하면 인수들 사이의 구분자를 제거할 수 있습니다."
                },
                {
                    question: "'논리적으로 실행 불가능한 명령문 작성 시 발생' 오류를 무엇이라고 하는가?",
                    options: ["의미 오류", "실행 오류", "구문 오류", "구조 오류"],
                    correct: 0,
                    explanation: "의미 오류는 문법적으로는 올바르지만 논리적으로 잘못된 코드에서 발생합니다."
                },
                {
                    question: "파이썬에서 명령어의 논리적 집합인 명령 블록을 표현하기 위한 방법은?",
                    options: ["불리언식", "들여쓰기", "콜론(:)", "if 명령어"],
                    correct: 1,
                    explanation: "파이썬은 들여쓰기로 코드 블록을 구분합니다."
                },
                {
                    question: "사용자가 입력한 수가 3과 5의 공배수일 경우를 판단하는 조건식에서 사용할 연산자는?",
                    options: ["and", "or", "True", "False"],
                    correct: 0,
                    explanation: "3의 배수이면서 동시에 5의 배수여야 하므로 and 연산자를 사용합니다."
                },
                {
                    question: "계수 제어 반복 구조에서 특정 반복 횟수와 반복 시 계수의 값을 정하기 위해 사용하는 데이터 타입은?",
                    options: ["반복 구조 설계 전략", "조건 제어 반복 구조", "시퀀스", "식별자"],
                    correct: 2,
                    explanation: "시퀀스는 for 반복문에서 반복 횟수와 값을 결정하는 데 사용됩니다."
                },
                {
                    question: "반복 구조 내부에 또 다른 반복 구조가 포함되어 실행 흐름을 만드는 구조를 무엇이라고 하는가?",
                    options: ["이분 선택 구조", "조건 제어 반복 구조", "계수 제어 반복 구조", "중첩 반복 구조"],
                    correct: 3,
                    explanation: "중첩 반복 구조는 반복문 안에 다른 반복문이 포함된 구조입니다."
                },
                {
                    question: "for i in range(2, 12): print(i, end=' ')의 출력 결과는?",
                    options: [
                        "2 3 4 5 6 7 8 9 10 11",
                        "2 3 4 5 6 7 8 9 10",
                        "1 2 3 4 5 6 7 8 9 10 11",
                        "1 2 3 4 5 6 7 8 9 10"
                    ],
                    correct: 0,
                    explanation: "range(2, 12)는 2부터 11까지의 숫자를 생성합니다."
                },
                {
                    question: "다음 중 반환값에 따른 함수의 종류를 구분할 때, 나머지와 다른 하나는?",
                    options: ["print", "input", "format", "int"],
                    correct: 0,
                    explanation: "print 함수는 None을 반환하는 프로시저이고, 나머지는 값을 반환하는 함수입니다."
                },
                {
                    question: "다음 중 객체지향 패러다임의 특징이라고 할 수 없는 것은?",
                    options: ["추상화", "캡슐화", "상속", "개방화"],
                    correct: 3,
                    explanation: "객체지향의 특징은 추상화, 캡슐화, 상속, 다형성입니다."
                },
                {
                    question: "파이썬 클래스에서 인스턴스 메서드의 첫 번째 매개변수로 사용되는 것은?",
                    options: ["'self'", "self", "access", "mutate"],
                    correct: 1,
                    explanation: "self는 인스턴스 메서드에서 객체 자신을 참조하는 매개변수입니다."
                },
                {
                    question: "클래스, 함수, 상수(변수)의 집합을 무엇이라고 하는가?",
                    options: ["라이브러리", "메소드", "네임스페이스", "모듈"],
                    correct: 3,
                    explanation: "모듈은 관련된 클래스, 함수, 변수들을 하나의 파일로 묶은 것입니다."
                },
                {
                    question: "다음 중 모듈 사용과 관련된 명령어가 아닌 것은?",
                    options: ["del", "import", "module", "from"],
                    correct: 2,
                    explanation: "module은 파이썬의 키워드가 아닙니다."
                },
                {
                    question: "option 리스트의 값 중 하나가 무작위로 선택되어 할당되도록 하는 올바른 코드는?",
                    options: ["choice(options)", "random.choice(options)", "random.choice(sequence)", "sample(sequence, 2)"],
                    correct: 1,
                    explanation: "random.choice()는 시퀀스에서 무작위로 하나의 요소를 선택합니다."
                },
                {
                    question: "데이터를 구성하는 개별 문자를 인코딩 체계를 통해 바이트로 변경하여 연속적으로 저장한 파일의 종류는?",
                    options: ["바이트 파일", "바이너리 파일", "텍스트 파일", "base64 파일"],
                    correct: 2,
                    explanation: "텍스트 파일은 문자 데이터를 인코딩하여 저장한 파일입니다."
                },
                {
                    question: "시퀀스에서 각각의 항목을 순서대로 한 번씩만 방문하는 과정은?",
                    options: ["순회", "검사", "회진", "샘플링"],
                    correct: 0,
                    explanation: "순회(iteration)는 시퀀스의 모든 요소를 차례대로 방문하는 과정입니다."
                },
                {
                    question: "파일에 텍스트 데이터를 추가하려고 할 때 사용하는 파일 모드는?",
                    options: ['"w"', '"r"', '"x"', '"a"'],
                    correct: 3,
                    explanation: '"a" 모드는 파일의 끝에 데이터를 추가(append)하는 모드입니다.'
                },
                {
                    question: "소프트웨어 개발 라이프사이클의 순서가 올바르게 나열된 것은?",
                    options: [
                        "계획, 분석, 설계, 구현, 테스트, 유지보수",
                        "유지보수, 구현, 설계, 테스트, 계획, 분석",
                        "계획, 분석, 설계, 테스트, 유지보수, 구현",
                        "설계, 계획, 분석, 구현, 유지보수, 테스트"
                    ],
                    correct: 0,
                    explanation: "소프트웨어 개발 라이프사이클은 계획→분석→설계→구현→테스트→유지보수 순서입니다."
                },
                {
                    question: "EDP 구동 구조에서 이벤트 발생 장치에 발생된 이벤트가 처리되기 전까지 저장되는 저장 구조는?",
                    options: ["이벤트 버퍼", "이벤트 메모리", "이벤트 큐", "이벤트 스토리지"],
                    correct: 2,
                    explanation: "이벤트 큐는 발생한 이벤트들을 순서대로 저장하는 자료구조입니다."
                },
                {
                    question: "일괄적으로 모아놓은 대량의 데이터를 특정시간에 지정한 처리 방법에 따라 처리하는 프로그램은?",
                    options: ["크론 프로그램", "배치 프로그램", "GUI 프로그램", "이벤트 기반 프로그램"],
                    correct: 1,
                    explanation: "배치 프로그램은 대량의 데이터를 일괄적으로 처리하는 프로그램입니다."
                },
                {
                    question: "0 또는 1의 난수 값이 생성되도록 하는 random 모듈의 함수는?",
                    options: ["random.random()", "random.randint(0, 1)", "random.choice(0, 1)", "random.sample(0, 1)"],
                    correct: 1,
                    explanation: "random.randint(0, 1)은 0과 1 사이의 정수를 무작위로 반환합니다."
                },
                {
                    question: "2차원 리스트 distance에서 특정 위치의 원소에 접근하는 올바른 방법은?",
                    options: ["[2][3]", "distance[2][3]", "distance[3][4]", "distance(3, 4)"],
                    correct: 1,
                    explanation: "2차원 리스트의 원소에 접근할 때는 리스트명[행][열] 형태를 사용합니다."
                },
                {
                    question: "0으로 초기화된 3×3 크기의 2차원 리스트를 생성할 때 빈 칸에 공통으로 들어갈 표현은?",
                    options: ["i", "j", "3", "[] 또는 list()"],
                    correct: 2,
                    explanation: "3×3 리스트를 만들기 위해서는 크기를 나타내는 숫자 3이 필요합니다."
                }
            ],
            html: [
                {
                    question: "HTML5에서 새롭게 추가된 시맨틱 태그가 아닌 것은?",
                    options: ["<article>", "<section>", "<nav>", "<font>"],
                    correct: 3,
                    explanation: "<font> 태그는 HTML5에서 권장되지 않는 태그입니다."
                },
                {
                    question: "CSS에서 클래스 선택자를 나타내는 기호는?",
                    options: ["#", ".", "*", "&"],
                    correct: 1,
                    explanation: "CSS에서 클래스 선택자는 점(.) 기호를 사용합니다."
                },
                {
                    question: "HTML 문서의 기본 구조로 올바른 것은?",
                    options: ["<html> - <head> - <body>", "<body> - <head> - <html>", "<head> - <html> - <body>", "<html> - <body> - <head>"],
                    correct: 0,
                    explanation: "HTML 문서는 html 태그 안에 head와 body 태그가 순서대로 위치합니다."
                },
                {
                    question: "JavaScript에서 HTML 요소를 선택하는 메소드는?",
                    options: ["selectElement()", "getElementById()", "findElement()", "chooseElement()"],
                    correct: 1,
                    explanation: "getElementById()는 ID로 HTML 요소를 선택하는 메소드입니다."
                },
                {
                    question: "HTML5에서 비디오를 재생하기 위한 태그는?",
                    options: ["<media>", "<video>", "<movie>", "<play>"],
                    correct: 1,
                    explanation: "HTML5의 <video> 태그를 사용하여 비디오를 재생할 수 있습니다."
                },
                {
                    question: "CSS의 박스 모델 구성요소가 아닌 것은?",
                    options: ["content", "padding", "border", "background"],
                    correct: 3,
                    explanation: "CSS 박스 모델은 content, padding, border, margin으로 구성됩니다."
                },
                {
                    question: "HTML에서 하이퍼링크를 만들 때 사용하는 태그는?",
                    options: ["<link>", "<a>", "<href>", "<url>"],
                    correct: 1,
                    explanation: "<a> 태그를 사용하여 하이퍼링크를 만듭니다."
                },
                {
                    question: "JavaScript에서 변수를 선언하는 키워드가 아닌 것은?",
                    options: ["var", "let", "const", "variable"],
                    correct: 3,
                    explanation: "JavaScript에서는 var, let, const를 사용하여 변수를 선언합니다."
                },
                {
                    question: "HTML5에서 입력 폼을 만들 때 사용하는 태그는?",
                    options: ["<input>", "<form>", "<field>", "①, ②번 모두 사용"],
                    correct: 3,
                    explanation: "<form> 태그 안에 <input> 태그를 사용하여 입력 폼을 만듭니다."
                },
                {
                    question: "CSS에서 텍스트 색상을 지정하는 속성은?",
                    options: ["text-color", "font-color", "color", "text-style"],
                    correct: 2,
                    explanation: "CSS에서는 color 속성을 사용하여 텍스트 색상을 지정합니다."
                },
                {
                    question: "HTML 문서는 반드시 <!DOCTYPE html>로 시작해야 한다.",
                    type: "ox",
                    correct: true,
                    explanation: "HTML5 문서는 <!DOCTYPE html>로 시작해야 합니다."
                },
                {
                    question: "CSS는 Cascading Style Sheets의 줄임말이다.",
                    type: "ox",
                    correct: true,
                    explanation: "CSS는 Cascading Style Sheets의 줄임말이 맞습니다."
                },
                {
                    question: "JavaScript는 클라이언트 사이드에서만 실행된다.",
                    type: "ox",
                    correct: false,
                    explanation: "JavaScript는 Node.js를 통해 서버 사이드에서도 실행할 수 있습니다."
                },
                {
                    question: "HTML5에서는 Flash 플러그인 없이도 비디오와 오디오를 재생할 수 있다.",
                    type: "ox",
                    correct: true,
                    explanation: "HTML5는 네이티브로 비디오와 오디오 재생을 지원합니다."
                },
                {
                    question: "CSS에서 ID 선택자는 #기호로 시작한다.",
                    type: "ox",
                    correct: true,
                    explanation: "CSS에서 ID 선택자는 # 기호로 시작합니다."
                },
                {
                    question: "HTML5의 Canvas 요소로 할 수 있는 작업이 아닌 것은?",
                    options: ["그래픽 그리기", "애니메이션 구현", "데이터베이스 연동", "이미지 조작"],
                    correct: 2,
                    explanation: "Canvas는 그래픽 작업에 사용되며 데이터베이스 연동은 서버 사이드에서 처리됩니다."
                },
                {
                    question: "JavaScript에서 배열을 선언하는 올바른 방법은?",
                    options: ["array = [1, 2, 3]", "array = (1, 2, 3)", "array = {1, 2, 3}", "array = <1, 2, 3>"],
                    correct: 0,
                    explanation: "JavaScript에서는 대괄호 []를 사용하여 배열을 선언합니다."
                },
                {
                    question: "HTML5에서 오디오 파일을 재생하는 태그는?",
                    options: ["<sound>", "<music>", "<audio>", "<mp3>"],
                    correct: 2,
                    explanation: "HTML5의 <audio> 태그를 사용하여 오디오를 재생할 수 있습니다."
                },
                {
                    question: "CSS에서 요소를 숨기는 속성은?",
                    options: ["display: none", "visibility: hidden", "opacity: 0", "위의 모든 방법 가능"],
                    correct: 3,
                    explanation: "CSS에서는 display: none, visibility: hidden, opacity: 0 모두 요소를 숨기는 방법입니다."
                },
                {
                    question: "HTML5에서 로컬 스토리지를 사용하는 JavaScript 객체는?",
                    options: ["localStorage", "sessionStorage", "webStorage", "①, ②번 모두 가능"],
                    correct: 3,
                    explanation: "HTML5에서는 localStorage와 sessionStorage 모두 로컬 스토리지 기능을 제공합니다."
                }
            ],
            java: [
                {
                    question: "Java 언어의 특징으로 올바른 것은?",
                    options: ["플랫폼에 종속적이다", "포인터를 사용한다", "객체지향 프로그래밍 언어이다", "컴파일 없이 바로 실행된다"],
                    correct: 2,
                    explanation: "Java는 객체지향 프로그래밍 언어로 플랫폼 독립적이고 포인터를 사용하지 않습니다."
                },
                {
                    question: "Java에서 클래스를 정의할 때 사용하는 키워드는?",
                    options: ["define", "class", "object", "struct"],
                    correct: 1,
                    explanation: "Java에서는 class 키워드를 사용하여 클래스를 정의합니다."
                },
                {
                    question: "다음 중 Java의 기본 데이터 타입이 아닌 것은?",
                    options: ["int", "boolean", "String", "double"],
                    correct: 2,
                    explanation: "String은 참조 타입이며, 기본 데이터 타입이 아닙니다."
                },
                {
                    question: "Java에서 배열을 선언할 때 틀린 방법은?",
                    options: ["int[] array;", "int array[];", "int[5] array;", "int[][] array;"],
                    correct: 2,
                    explanation: "Java에서는 배열 선언 시 크기를 지정할 수 없습니다."
                },
                {
                    question: "Java의 main 메소드 선언으로 올바른 것은?",
                    options: ["public static void main(String args[])", "private void main(String[] args)", "public main(String[] args)", "static main(String args)"],
                    correct: 0,
                    explanation: "Java의 main 메소드는 public static void로 선언되어야 합니다."
                },
                {
                    question: "Java에서 상속을 나타내는 키워드는?",
                    options: ["inherit", "extends", "implements", "super"],
                    correct: 1,
                    explanation: "Java에서는 extends 키워드를 사용하여 상속을 구현합니다."
                },
                {
                    question: "Java의 접근 제어자가 아닌 것은?",
                    options: ["public", "private", "protected", "internal"],
                    correct: 3,
                    explanation: "Java의 접근 제어자는 public, private, protected, default(package)입니다."
                },
                {
                    question: "다음 중 Java의 반복문이 아닌 것은?",
                    options: ["for", "while", "do-while", "repeat-until"],
                    correct: 3,
                    explanation: "Java에는 repeat-until 반복문이 없습니다."
                },
                {
                    question: "Java에서 예외 처리에 사용되는 키워드가 아닌 것은?",
                    options: ["try", "catch", "finally", "handle"],
                    correct: 3,
                    explanation: "Java에서는 try-catch-finally를 사용하여 예외를 처리합니다."
                },
                {
                    question: "Java에서 추상 클래스를 선언할 때 사용하는 키워드는?",
                    options: ["abstract", "virtual", "interface", "final"],
                    correct: 0,
                    explanation: "Java에서는 abstract 키워드를 사용하여 추상 클래스를 선언합니다."
                },
                // 기출문제 추가 (총 30문제 중 20문제가 랜덤 선택됨)
                {
                    question: "Java 프로그램의 다음 코드에서 주석의 개수는 몇 개인가?\n```java\n/**\n * This is my first java program.\n */\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\"); // prints Hello World\n    }\n}\n```",
                    options: ["1개", "2개", "3개", "4개"],
                    correct: 1,
                    explanation: "/** */ 형태의 문서 주석 1개와 // 형태의 한줄 주석 1개로 총 2개입니다."
                },
                {
                    question: "다음 Circle 클래스에서 PI 상수를 선언할 때 적절한 접근제어자는 무엇인가?\n```java\nclass Circle {\n    _______ double PI = 3.14;  // 상수\n    private double r;\n    \n    public Circle(double r) { this.r = r; }\n    void setR(double r) { this.r = r; }\n}\n```",
                    options: ["final static", "public static", "static private", "public final"],
                    correct: 1,
                    explanation: "PI는 수학 상수로 모든 클래스에서 접근 가능해야 하므로 public이고, 객체 생성 없이 사용할 수 있도록 static으로 선언합니다."
                },
                {
                    question: "다음 중 생성자의 올바른 선언 형태는 무엇인가?",
                    options: ["private Circle(double r)", "public Circle(double r)", "private void Circle(double r)", "public void Circle(double r)"],
                    correct: 1,
                    explanation: "생성자는 반환형이 없고, 클래스명과 동일한 이름을 가져야 합니다. 일반적으로 public으로 선언합니다."
                },
                {
                    question: "Java 개발환경의 구성요소가 아닌 것은 무엇인가?",
                    options: ["Java Platform", "Java VM", "JDK", "Eclipse for JavaScript"],
                    correct: 3,
                    explanation: "Eclipse for JavaScript는 Java 개발환경이 아닌 JavaScript 개발을 위한 도구입니다."
                },
                {
                    question: "배열의 선언과 초기화 중 올바르지 않은 것은?",
                    options: ["int[] a = new int[10];", "int b[] = { 1, 2, 3, 4 };", "int[] c; c = {1, 2, 3, 4};", "int[][] d = new int[10][];"],
                    correct: 2,
                    explanation: "배열을 별도로 선언한 후 초기화할 때는 new int[]{1, 2, 3, 4} 형태로 써야 합니다."
                },
                {
                    question: "int형 변수 i와 j의 값을 공백으로 구분하여 출력하는 올바른 방법은?",
                    options: ["System.out.println( i + j );", "System.out.println( i + \" \" + j );", "System.out.println( i , j );", "System.out.println( i , \"=\" , j );"],
                    correct: 1,
                    explanation: "문자열 연결 연산자(+)를 사용하여 공백(\" \")을 중간에 넣어 출력합니다."
                },
                {
                    question: "B와 C가 클래스이고 Y와 Z가 인터페이스일 때, 다음 중 문법적으로 올바른 것은?",
                    options: ["class A extends B, C { }", "class A extends B, Y { }", "class A implements Y, Z { }", "interface X extends Y, Z { }"],
                    correct: 2,
                    explanation: "클래스는 하나의 클래스만 상속받을 수 있지만(extends), 여러 인터페이스를 구현할 수 있습니다(implements)."
                },
                {
                    question: "다음 상속관계에서 부모클래스의 메소드를 자식클래스에서 재정의할 때 사용하는 접근제어자로 올바른 것은?\n```java\n// 부모클래스의 메소드\nprotected double compute(int x, int y)\n```",
                    options: ["private double compute(int x, int y)", "protected double compute(int x, int y)", "public double compute(int x, int y)", "②, ③번 모두 가능"],
                    correct: 3,
                    explanation: "메소드 오버라이딩 시 접근제어자는 부모클래스와 같거나 더 넓은 범위여야 합니다. protected → protected, public 가능합니다."
                },
                {
                    question: "Circle 클래스에서 반지름 r이 private으로 선언되어 있을 때, 외부에서 r값을 10으로 설정하는 올바른 방법은?\n```java\nCircle c = new Circle(0);\n```",
                    options: ["c.r = 10;", "c.setR(10);", "c.getR(10);", "Circle.r = 10;"],
                    correct: 1,
                    explanation: "private 멤버변수는 직접 접근할 수 없으므로 setter 메소드를 통해 값을 설정해야 합니다."
                },
                {
                    question: "Java에서 다음 중 올바른 메인 메소드 선언은?",
                    options: ["public static void main(String args)", "public static void main(String[] args)", "public void main(String[] args)", "static void main(String[] args)"],
                    correct: 1,
                    explanation: "Java의 메인 메소드는 public static void main(String[] args) 형태로 선언해야 합니다."
                },
                {
                    question: "Java는 \"Write Once, Run Anywhere\"의 특징을 갖는다.",
                    type: "ox",
                    correct: true,
                    explanation: "Java는 JVM을 통해 플랫폼 독립적으로 실행될 수 있습니다."
                },
                {
                    question: "Java에서 가비지 컬렉션은 개발자가 직접 실행해야 한다.",
                    type: "ox",
                    correct: false,
                    explanation: "Java의 가비지 컬렉션은 JVM에 의해 자동으로 실행됩니다."
                },
                {
                    question: "Java에서 클래스명과 파일명은 반드시 같아야 한다.",
                    type: "ox",
                    correct: true,
                    explanation: "Java에서 public 클래스의 이름과 파일명은 반드시 같아야 합니다."
                },
                {
                    question: "Java는 다중 상속을 지원한다.",
                    type: "ox",
                    correct: false,
                    explanation: "Java는 클래스의 다중 상속을 지원하지 않습니다(인터페이스는 가능)."
                },
                {
                    question: "Java에서 모든 클래스는 Object 클래스를 상속받는다.",
                    type: "ox",
                    correct: true,
                    explanation: "Java에서 모든 클래스는 직간접적으로 Object 클래스를 상속받습니다."
                },
                {
                    question: "Java의 컬렉션 프레임워크에서 List 인터페이스를 구현하지 않는 클래스는?",
                    options: ["ArrayList", "LinkedList", "Vector", "HashSet"],
                    correct: 3,
                    explanation: "HashSet은 Set 인터페이스를 구현하며 List 인터페이스는 구현하지 않습니다."
                },
                {
                    question: "Java에서 문자열을 비교할 때 올바른 방법은?",
                    options: ["str1 == str2", "str1.equals(str2)", "str1.compare(str2)", "str1 = str2"],
                    correct: 1,
                    explanation: "Java에서는 equals() 메소드를 사용하여 문자열 내용을 비교합니다."
                },
                {
                    question: "Java의 가비지 컬렉션에 대한 설명으로 올바른 것은?",
                    options: [
                        "개발자가 직접 메모리를 해제해야 한다",
                        "자동으로 사용하지 않는 객체의 메모리를 회수한다",
                        "C언어의 free() 함수와 동일하다",
                        "프로그램 종료 시에만 실행된다"
                    ],
                    correct: 1,
                    explanation: "Java의 가비지 컬렉션은 더 이상 참조되지 않는 객체의 메모리를 자동으로 회수합니다."
                },
                {
                    question: "Java에서 인터페이스에 대한 설명으로 틀린 것은?",
                    options: [
                        "다중 상속을 지원한다",
                        "모든 메소드는 추상 메소드이다",
                        "인스턴스 변수를 가질 수 있다",
                        "implements 키워드로 구현한다"
                    ],
                    correct: 2,
                    explanation: "인터페이스는 인스턴스 변수를 가질 수 없으며, 상수만 선언할 수 있습니다."
                },
                {
                    question: "Java의 패키지에 대한 설명으로 올바른 것은?",
                    options: [
                        "클래스들을 논리적으로 그룹화한다",
                        "import 문으로 사용한다",
                        "네임스페이스 기능을 제공한다",
                        "위의 모든 설명이 올바르다"
                    ],
                    correct: 3,
                    explanation: "Java의 패키지는 클래스들을 그룹화하고 네임스페이스를 제공하며 import로 사용합니다."
                },
                // 기존 java 문제 배열에 추가할 내용들:
                {
                    question: "Java 언어의 특징이 아닌 것은?",
                    options: ["엄격한 자료형의 검사", "플랫폼에 독립적", "예외처리 기능의 지원", "멀티 스레딩의 지원"],
                    correct: -1, // 모두 Java의 특징이므로 적절한 오답 선택지로 수정 필요
                    explanation: "제시된 모든 항목이 Java의 특징입니다."
                },
                {
                    question: "public class A { } class B { } 이 파일의 이름이 A.java일 때, 컴파일 결과는?",
                    options: ["A.class만 생성된다", "B.class만 생성된다", "A.class와 B.class가 생성된다", "오류가 있어 컴파일되지 않는다"],
                    correct: 2,
                    explanation: "각 클래스마다 별도의 .class 파일이 생성됩니다."
                },
                {
                    question: "다음 중 클래스 이름에 해당하지 않는 것은?",
                    options: ["Integer", "String", "System", "boolean"],
                    correct: 3,
                    explanation: "boolean은 기본 데이터 타입이며 클래스 이름이 아닙니다."
                },
                {
                    question: "다음 정수 리터럴 중 값이 다른 하나는?",
                    options: ["10", "00001010", "0x0A", "0b0000_1010"],
                    correct: 1,
                    explanation: "00001010은 8진수로 520을 의미하며, 나머지는 모두 10진수 10입니다."
                },
                {
                    question: "다음 중 문법적으로 올바른 배열 선언은?",
                    options: ["int a[10] = new int[ ];", "int b[ ] = new int(10);", "int[ ][ ] c = new int[5][ ];", "int[5] d = {1, 2, 3, 4, 5};"],
                    correct: 2,
                    explanation: "다차원 배열에서 첫 번째 차원의 크기는 반드시 지정해야 합니다."
                },
                // {
                //     question: "int형 변수 i와 j의 값을 공백으로 구분하여 출력하는 올바른 방법은?",
                //     options: ["System.out.println( i , j );", "System.out.println( i + \" \" + j );", "System.out.println( i + j );", "System.out.println( i + '=' + j );"],
                //     correct: 1,
                //     explanation: "문자열 연결 연산자(+)를 사용하여 공백(\" \")을 중간에 넣어 출력합니다."
                // },
                {
                    question: "제네릭 클래스 Data<T>가 있을 때, 문법적으로 오류가 있는 것은?",
                    options: ["Data<int> d = new Data<>();", "Data<Integer> d = new Data<>();", "Data<String> d = new Data<String>();", "Data d = new Data();"],
                    correct: 0,
                    explanation: "제네릭에서는 기본 타입(primitive type)을 사용할 수 없고, 래퍼 클래스를 사용해야 합니다."
                },
                {
                    question: "인터페이스 Addable { int add(int a, int b); }에서 람다식 사용이 잘못된 것은?",
                    options: ["(int a, int b) -> { return (a + b); }", "(int a, int b) -> a + b", "(a, b) -> return (a + b)", "(a, b) -> (a + b)"],
                    correct: 2,
                    explanation: "람다식에서 중괄호 없이 return 키워드를 사용할 수 없습니다."
                },
                {
                    question: "Client 클래스를 myprogram.game 패키지에 위치시키려면 소스 파일 맨 위에 무엇을 작성해야 하는가?",
                    options: ["package myprogram.game;", "package myprogram.game.Client;", "import myprogram.game;", "import myprogram.game.Client;"],
                    correct: 0,
                    explanation: "패키지 선언은 'package 패키지명;' 형태로 작성합니다."
                },
                {
                    question: "Object 클래스와 String 클래스에 대한 설명 중 잘못된 것은?",
                    options: [
                        "모든 클래스는 묵시적으로 Object 클래스를 상속받는다",
                        "Object 클래스에 toString()과 equals() 메소드가 정의되어 있다",
                        "String 클래스에 toString()과 equals() 메소드가 재정의되어 있다",
                        "String 클래스는 표준 입출력 스트림을 위한 static 필드를 제공한다"
                    ],
                    correct: 3,
                    explanation: "표준 입출력 스트림은 System 클래스에서 제공합니다."
                },
                {
                    question: "다음 중 기본 스트림에 해당하지 않는 것은?",
                    options: ["StringReader", "FileReader", "ByteArrayInputStream", "BufferedReader"],
                    correct: 3,
                    explanation: "BufferedReader는 보조 스트림(보조 클래스)입니다."
                },
                {
                    question: "BufferedReader 클래스에 관한 설명으로 틀린 것은?",
                    options: [
                        "Reader의 자식 클래스이다",
                        "read()와 readLine() 등 다양한 입력 메소드를 제공한다",
                        "바이트 단위의 입력 기능을 제공한다",
                        "입력 과정에 버퍼링 기능을 제공한다"
                    ],
                    correct: 2,
                    explanation: "BufferedReader는 문자 단위 입력을 제공하며, 바이트 단위는 InputStream 계열에서 제공합니다."
                },
                {
                    question: "Path 인터페이스에 관한 설명 중 잘못된 것은?",
                    options: [
                        "java.io.File 클래스를 대체할 수 있다",
                        "파일시스템에 존재하는 파일 또는 디렉터리의 경로를 표현한다",
                        "경로의 생성, 경로의 조작/비교, 경로의 요소를 조회하는 기능을 제공한다",
                        "파일 내용의 읽기와 쓰기 기능을 제공한다"
                    ],
                    correct: 3,
                    explanation: "Path는 경로 정보만 다루며, 파일 읽기/쓰기는 Files 클래스나 다른 IO 클래스를 사용합니다."
                },
                {
                    question: "FileChannel 클래스에 관한 설명으로 틀린 것은?",
                    options: [
                        "java.io 패키지의 파일 관련 스트림 클래스를 대체하기 위한 클래스이다",
                        "FileChannel.open(path)으로 객체 생성을 하면 해당 파일을 읽기용으로 열게 된다",
                        "파일 입력을 위해 FileChannelReader, 파일 출력을 위해 FileChannelWriter를 사용한다",
                        "멀티 스레드 환경에서도 안전하게 사용할 수 있게 설계되었다"
                    ],
                    correct: 2,
                    explanation: "FileChannel은 직접 read/write 메소드를 제공하며, 별도의 Reader/Writer 클래스를 사용하지 않습니다."
                },
                {
                    question: "ArrayList 클래스에 관한 설명으로 적당하지 않은 것은?",
                    options: [
                        "List 인터페이스를 구현한 클래스이다",
                        "여러 원소를 저장하기 위해 내부적으로 배열을 사용한다",
                        "원소의 순서가 의미를 가진다",
                        "같은 자료를 중복으로 저장할 수 없다"
                    ],
                    correct: 3,
                    explanation: "ArrayList는 중복된 요소를 저장할 수 있습니다."
                },
                {
                    question: "(key, value) 형태의 원소로 구성되는 자료 묶음을 다루기 위한 인터페이스나 클래스가 아닌 것은?",
                    options: ["HashMap", "HashSet", "Hashtable", "Map"],
                    correct: 1,
                    explanation: "HashSet은 Set 인터페이스를 구현하며 단일 값만 저장합니다."
                },
                {
                    question: "주어진 배열을 스트림으로 만들 때 사용하는 올바른 방법은?",
                    options: ["IntStream.range(numbers)", "Arrays.stream(numbers)", "numbers.stream()", "numbers.getStream()"],
                    correct: 1,
                    explanation: "Arrays.stream() 메소드를 사용하여 배열을 스트림으로 변환합니다."
                },
                {
                    question: "스레드 동기화의 의미를 가장 잘 설명한 것은?",
                    options: [
                        "메인 스레드가 가장 마지막에 종료되는 것을 보장하는 것",
                        "공유 객체에 여러 스레드들이 동시 접근할 수 있게 하는 것",
                        "한순간에 한 스레드만 공유 객체에 접근할 수 있게 하는 것",
                        "여러 개의 스레드들이 순서대로 하나씩 수행되게 하는 것"
                    ],
                    correct: 2,
                    explanation: "스레드 동기화는 공유 자원에 대한 동시 접근을 제어하는 것입니다."
                },
                {
                    question: "JDBC 프로그래밍에 사용되는 클래스나 인터페이스가 아닌 것은?",
                    options: ["Connection", "DriverManager", "Statement", "Runnable"],
                    correct: 3,
                    explanation: "Runnable은 스레드 관련 인터페이스이며 JDBC와는 관련이 없습니다."
                },
                {
                    question: "PreparedStatement 객체에 대한 설명으로 잘못된 것은?",
                    options: [
                        "PreparedStatement는 Statement의 부모 인터페이스이다",
                        "객체를 생성할 때 SQL 구문을 지정해야 한다",
                        "같은 SQL 구문을 여러 번 실행할 때 효율적으로 활용될 수 있다",
                        "매개 변수를 가지는 SQL 구문을 저장할 수 있다"
                    ],
                    correct: 0,
                    explanation: "PreparedStatement는 Statement의 하위 인터페이스입니다."
                },
                {
                    question: ".jar 파일 형식으로 배포된 라이브러리를 사용하고자 할 때, 이러한 .jar 파일을 어떤 환경 변수에 추가해야 하는가?",
                    options: ["Classpath", "Modulepath", "Javadoc", "Jarpath"],
                    correct: 0,
                    explanation: "jar 파일은 Classpath 환경 변수에 추가해야 합니다."
                },
                {
                    question: "Java의 표준 모듈 중 requires 키워드로 사용 선언을 하지 않아도 사용이 가능한 모듈은?",
                    options: ["jdk.base", "jdk.lang", "java.lang", "java.base"],
                    correct: 3,
                    explanation: "java.base 모듈은 모든 Java 애플리케이션에서 자동으로 사용됩니다."
                }
            ]
        };

        // 초기화
        document.addEventListener('DOMContentLoaded', function() {
            loadStats();
            updateStatsDisplay();
        });

        // 통계 로드 (localStorage에서)
        function loadStats() {
            const savedStats = localStorage.getItem('knouExamStats');
            if (savedStats) {
                examStats = JSON.parse(savedStats);
            }
            
            const savedWrongAnswers = localStorage.getItem('knouWrongAnswers');
            if (savedWrongAnswers) {
                wrongAnswersHistory = JSON.parse(savedWrongAnswers);
            }
        }

        // 통계 저장 (localStorage에)
        function saveStats() {
            localStorage.setItem('knouExamStats', JSON.stringify(examStats));
            localStorage.setItem('knouWrongAnswers', JSON.stringify(wrongAnswersHistory));
        }

        // 통계 업데이트
        function updateStatsDisplay() {
            Object.keys(examStats).forEach(subject => {
                const bestElement = document.getElementById(`${subject}-best`);
                const countElement = document.getElementById(`${subject}-count`);
                if (bestElement) bestElement.textContent = examStats[subject].best;
                if (countElement) countElement.textContent = examStats[subject].count;
            });
        }

        // 시험 시작
        function startExam(subject) {
            currentSubject = subject;
            currentQuestionIndex = 0;
            userAnswers = [];
            examStartTime = Date.now();
            examTimeLeft = examTimeLimit;

            // 문제 준비 - 랜덤으로 20문제 선택
            if (subject === 'mixed') {
                currentQuestions = getMixedQuestions();
            } else {
                currentQuestions = [...questionDatabase[subject]];
                shuffleArray(currentQuestions);
                currentQuestions = currentQuestions.slice(0, 20); // 랜덤 20문제 선택
            }

            // 사용자 답안 초기화
            userAnswers = new Array(currentQuestions.length).fill(null);

            showScreen('examScreen');
            displayQuestion();
            startTimer();
        }

        // 혼합 문제 생성
        function getMixedQuestions() {
            const allQuestions = [];
            Object.keys(questionDatabase).forEach(subject => {
                if (subject !== 'mixed') {
                    allQuestions.push(...questionDatabase[subject]);
                }
            });
            shuffleArray(allQuestions);
            return allQuestions.slice(0, 20);
        }

        // 배열 섞기
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // 화면 전환
        function showScreen(screenId) {
            const screens = ['mainScreen', 'examScreen', 'resultScreen', 'wrongAnswerScreen'];
            screens.forEach(screen => {
                document.getElementById(screen).classList.add('hidden');
            });
            document.getElementById(screenId).classList.remove('hidden');
            document.getElementById(screenId).classList.add('fade-in');
        }

        // 문제 표시
        function displayQuestion() {
            const question = currentQuestions[currentQuestionIndex];
            const subjectNames = {
                computer: '💻 컴퓨터의이해',
                ubiquitous: '🌐 유비쿼터스컴퓨팅개론',
                python: '🐍 파이썬프로그래밍기초',
                html: '🌍 HTML5웹프로그래밍',
                java: '☕ Java프로그래밍',
                mixed: '🎯 종합시험'
            };

            document.getElementById('currentSubject').textContent = subjectNames[currentSubject];
            document.getElementById('currentQuestionNum').textContent = currentQuestionIndex + 1;
            document.getElementById('totalQuestions').textContent = currentQuestions.length;

            // 진행률 업데이트
            const progress = ((currentQuestionIndex + 1) / currentQuestions.length) * 100;
            document.getElementById('progressFill').style.width = progress + '%';

            // 문제 텍스트 표시
            let questionText = question.question;
            let codeText = '';
            
            // 코드 블록 분리
            if (questionText.includes('```')) {
                const parts = questionText.split('```');
                questionText = parts[0];
                if (parts.length > 1) {
                    codeText = parts[1].replace(/^python\n/, '').replace(/^javascript\n/, '').replace(/^java\n/, '');
                    if (parts.length > 2) {
                        questionText += parts[2];
                    }
                }
            }

            document.getElementById('questionText').textContent = questionText;
            
            if (codeText) {
                document.getElementById('questionCode').style.display = 'block';
                document.getElementById('questionCode').textContent = codeText;
            } else {
                document.getElementById('questionCode').style.display = 'none';
            }

            // 선택지 표시
            const optionsContainer = document.getElementById('optionsContainer');
            optionsContainer.innerHTML = '';

            if (question.type === 'ox') {
                // O/X 문제
                const options = ['O (참)', 'X (거짓)'];
                options.forEach((option, index) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'option';
                    optionDiv.textContent = option;
                    optionDiv.onclick = () => selectAnswer(index === 0);
                    
                    if (userAnswers[currentQuestionIndex] === (index === 0)) {
                        optionDiv.classList.add('selected');
                    }
                    
                    optionsContainer.appendChild(optionDiv);
                });
            } else {
                // 객관식 문제
                question.options.forEach((option, index) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'option';
                    optionDiv.textContent = `${String.fromCharCode(65 + index)}. ${option}`;
                    optionDiv.onclick = () => selectAnswer(index);
                    
                    if (userAnswers[currentQuestionIndex] === index) {
                        optionDiv.classList.add('selected');
                    }
                    
                    optionsContainer.appendChild(optionDiv);
                });
            }

            // 버튼 상태 업데이트
            updateNavigationButtons();
        }

        // 답안 선택
        function selectAnswer(answer) {
            userAnswers[currentQuestionIndex] = answer;
            
            // 선택 표시 업데이트
            const options = document.querySelectorAll('.option');
            options.forEach((option, index) => {
                option.classList.remove('selected');
                const question = currentQuestions[currentQuestionIndex];
                if (question.type === 'ox') {
                    if ((index === 0 && answer === true) || (index === 1 && answer === false)) {
                        option.classList.add('selected');
                    }
                } else {
                    if (index === answer) {
                        option.classList.add('selected');
                    }
                }
            });
        }

        // 네비게이션 버튼 업데이트
        function updateNavigationButtons() {
            const nextBtn = document.getElementById('nextBtn');
            if (currentQuestionIndex === currentQuestions.length - 1) {
                nextBtn.textContent = '완료';
                nextBtn.onclick = finishExam;
            } else {
                nextBtn.textContent = '다음 ▶';
                nextBtn.onclick = nextQuestion;
            }
        }

        // 다음 문제
        function nextQuestion() {
            if (currentQuestionIndex < currentQuestions.length - 1) {
                currentQuestionIndex++;
                displayQuestion();
            }
        }

        // 이전 문제
        function previousQuestion() {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                displayQuestion();
            }
        }

        // 타이머 시작
        function startTimer() {
            examTimer = setInterval(() => {
                examTimeLeft--;
                updateTimerDisplay();
                
                if (examTimeLeft <= 0) {
                    finishExam();
                }
            }, 1000);
        }

        // 타이머 표시 업데이트
        function updateTimerDisplay() {
            const minutes = Math.floor(examTimeLeft / 60);
            const seconds = examTimeLeft % 60;
            document.getElementById('timer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // 시험 종료
        function finishExam() {
            if (examTimer) {
                clearInterval(examTimer);
            }

            const score = calculateScore();
            const timeUsed = Math.floor((Date.now() - examStartTime) / 1000);
            
            // 통계 업데이트
            examStats[currentSubject].count++;
            if (score > examStats[currentSubject].best) {
                examStats[currentSubject].best = score;
            }

            // 틀린 문제 저장
            saveWrongAnswers();

            // 데이터 저장
            saveStats();

            // 결과 화면 표시
            showResults(score, timeUsed);
            showScreen('resultScreen');
            updateStatsDisplay();
        }

        // 점수 계산
        function calculateScore() {
            let correct = 0;
            currentQuestions.forEach((question, index) => {
                if (userAnswers[index] !== null) {
                    if (question.type === 'ox') {
                        if (userAnswers[index] === question.correct) {
                            correct++;
                        }
                    } else {
                        if (userAnswers[index] === question.correct) {
                            correct++;
                        }
                    }
                }
            });
            return Math.round((correct / currentQuestions.length) * 100);
        }

        // 틀린 문제 저장
        function saveWrongAnswers() {
            currentQuestions.forEach((question, index) => {
                let isCorrect = false;
                if (userAnswers[index] !== null) {
                    if (question.type === 'ox') {
                        isCorrect = userAnswers[index] === question.correct;
                    } else {
                        isCorrect = userAnswers[index] === question.correct;
                    }
                }

                if (!isCorrect) {
                    const wrongAnswer = {
                        subject: currentSubject,
                        question: question,
                        userAnswer: userAnswers[index],
                        timestamp: new Date().toLocaleString()
                    };
                    
                    // 중복 제거
                    const exists = wrongAnswersHistory.some(item => 
                        item.question.question === question.question
                    );
                    if (!exists) {
                        wrongAnswersHistory.push(wrongAnswer);
                    }
                }
            });
        }

        // 결과 표시
        function showResults(score, timeUsed) {
            const correct = Math.round((score / 100) * currentQuestions.length);
            const incorrect = currentQuestions.length - correct;
            const timeUsedMinutes = Math.floor(timeUsed / 60);

            document.getElementById('finalScore').textContent = score + '점';
            document.getElementById('correctCount').textContent = correct;
            document.getElementById('incorrectCount').textContent = incorrect;
            document.getElementById('accuracy').textContent = score + '%';
            document.getElementById('timeUsed').textContent = timeUsedMinutes + '분';

            // 틀린 문제 표시
            if (incorrect > 0) {
                displayWrongAnswersInResult();
            } else {
                document.getElementById('wrongAnswersContainer').style.display = 'none';
            }
        }

        // 결과 화면에서 틀린 문제 표시
        function displayWrongAnswersInResult() {
            const container = document.getElementById('wrongAnswersContainer');
            const list = document.getElementById('wrongQuestionsList');
            
            list.innerHTML = '';
            
            currentQuestions.forEach((question, index) => {
                let isCorrect = false;
                if (userAnswers[index] !== null) {
                    if (question.type === 'ox') {
                        isCorrect = userAnswers[index] === question.correct;
                    } else {
                        isCorrect = userAnswers[index] === question.correct;
                    }
                }

                if (!isCorrect) {
                    const wrongDiv = document.createElement('div');
                    wrongDiv.className = 'wrong-question';
                    
                    let userAnswerText = '무응답';
                    if (userAnswers[index] !== null) {
                        if (question.type === 'ox') {
                            userAnswerText = userAnswers[index] ? 'O' : 'X';
                        } else {
                            userAnswerText = String.fromCharCode(65 + userAnswers[index]);
                        }
                    }

                    let correctAnswerText;
                    if (question.type === 'ox') {
                        correctAnswerText = question.correct ? 'O' : 'X';
                    } else {
                        correctAnswerText = String.fromCharCode(65 + question.correct);
                    }

                    wrongDiv.innerHTML = `
                        <strong>문제 ${index + 1}:</strong> ${question.question}<br>
                        <strong>선택한 답:</strong> ${userAnswerText}<br>
                        <strong>정답:</strong> ${correctAnswerText}<br>
                        <strong>해설:</strong> ${question.explanation}
                    `;
                    
                    list.appendChild(wrongDiv);
                }
            });
            
            container.style.display = 'block';
        }

        // 시험 재시작
        function restartExam() {
            startExam(currentSubject);
        }

        // 틀린 문제 복습
        function reviewWrongAnswers() {
            // 현재 시험에서 틀린 문제들만 추출
            const wrongQuestions = [];
            currentQuestions.forEach((question, index) => {
                let isCorrect = false;
                if (userAnswers[index] !== null) {
                    if (question.type === 'ox') {
                        isCorrect = userAnswers[index] === question.correct;
                    } else {
                        isCorrect = userAnswers[index] === question.correct;
                    }
                }
                if (!isCorrect) {
                    wrongQuestions.push(question);
                }
            });

            if (wrongQuestions.length === 0) {
                alert('틀린 문제가 없습니다!');
                return;
            }

            // 틀린 문제로 새 시험 시작
            currentQuestions = wrongQuestions;
            currentQuestionIndex = 0;
            userAnswers = new Array(currentQuestions.length).fill(null);
            examStartTime = Date.now();
            examTimeLeft = Math.min(currentQuestions.length * 60, 1800); // 문제당 1분, 최대 30분

            showScreen('examScreen');
            displayQuestion();
            startTimer();
        }

        // 홈으로
        function goHome() {
            if (examTimer) {
                clearInterval(examTimer);
            }
            showScreen('mainScreen');
        }

        // 오답노트 보기
        function showWrongAnswers() {
            const container = document.getElementById('wrongAnswersList');
            container.innerHTML = '';

            if (wrongAnswersHistory.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #718096; margin: 50px 0;">저장된 오답이 없습니다.</p>';
            } else {
                const subjectNames = {
                    computer: '💻 컴퓨터의이해',
                    ubiquitous: '🌐 유비쿼터스컴퓨팅개론',
                    python: '🐍 파이썬프로그래밍기초',
                    html: '🌍 HTML5웹프로그래밍',
                    java: '☕ Java프로그래밍',
                    mixed: '🎯 종합시험'
                };

                wrongAnswersHistory.forEach((item, index) => {
                    const wrongDiv = document.createElement('div');
                    wrongDiv.className = 'wrong-question';
                    
                    let userAnswerText = '무응답';
                    if (item.userAnswer !== null) {
                        if (item.question.type === 'ox') {
                            userAnswerText = item.userAnswer ? 'O' : 'X';
                        } else {
                            userAnswerText = String.fromCharCode(65 + item.userAnswer);
                        }
                    }

                    let correctAnswerText;
                    if (item.question.type === 'ox') {
                        correctAnswerText = item.question.correct ? 'O' : 'X';
                    } else {
                        correctAnswerText = String.fromCharCode(65 + item.question.correct);
                    }

                    wrongDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <strong>${subjectNames[item.subject]}</strong>
                            <small>${item.timestamp}</small>
                        </div>
                        <strong>문제:</strong> ${item.question.question}<br>
                        <strong>선택한 답:</strong> ${userAnswerText}<br>
                        <strong>정답:</strong> ${correctAnswerText}<br>
                        <strong>해설:</strong> ${item.question.explanation}
                    `;
                    
                    container.appendChild(wrongDiv);
                });
            }

            showScreen('wrongAnswerScreen');
        }

        // 데이터 초기화 확인
        function resetAllData() {
            showConfirmModal('데이터 초기화', '모든 통계와 오답 데이터를 삭제하시겠습니까?', () => {
                // 통계 초기화
                Object.keys(examStats).forEach(subject => {
                    examStats[subject] = { best: 0, count: 0 };
                });
                
                // 오답 히스토리 초기화
                wrongAnswersHistory = [];
                
                // 데이터 저장
                saveStats();
                
                updateStatsDisplay();
                alert('데이터가 초기화되었습니다.');
            });
        }

        // 확인 모달 표시
        function showConfirmModal(title, message, callback) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').textContent = message;
            confirmCallback = callback;
            document.getElementById('confirmModal').style.display = 'block';
        }

        // 모달 닫기
        function closeModal() {
            document.getElementById('confirmModal').style.display = 'none';
            confirmCallback = null;
        }

        // 확인 액션 실행
        function confirmAction() {
            if (confirmCallback) {
                confirmCallback();
            }
            closeModal();
        }

        // 모달 외부 클릭 시 닫기
        window.onclick = function(event) {
            const modal = document.getElementById('confirmModal');
            if (event.target === modal) {
                closeModal();
            }
        }
    </script>
</body>
</html>
