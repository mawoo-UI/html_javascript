<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>방송통신대학교 컴퓨터과학과 시험 대비</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .subject-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .subject-card {
            background: linear-gradient(145deg, #f0f4f8, #d9e2ec);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
        }

        .subject-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            border-color: #667eea;
        }

        .subject-card h3 {
            color: #2d3748;
            margin-bottom: 10px;
            font-size: 1.3rem;
        }

        .subject-card p {
            color: #718096;
            font-size: 0.9rem;
            margin-bottom: 15px;
        }

        .subject-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #4a5568;
        }

        .btn {
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .btn-secondary {
            background: linear-gradient(145deg, #718096, #4a5568);
            box-shadow: 0 4px 15px rgba(113, 128, 150, 0.4);
        }

        .btn-danger {
            background: linear-gradient(145deg, #fc8181, #e53e3e);
            box-shadow: 0 4px 15px rgba(252, 129, 129, 0.4);
        }

        .question-container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e2e8f0;
        }

        .question-info {
            font-size: 1.1rem;
            color: #4a5568;
        }

        .timer {
            background: linear-gradient(145deg, #fc8181, #e53e3e);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        .question-text {
            font-size: 1.3rem;
            line-height: 1.6;
            margin-bottom: 25px;
            color: #2d3748;
        }

        .question-code {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            white-space: pre-wrap;
        }

        .options {
            display: grid;
            gap: 15px;
        }

        .option {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1rem;
        }

        .option:hover {
            border-color: #667eea;
            background: #edf2f7;
        }

        .option.selected {
            border-color: #667eea;
            background: linear-gradient(145deg, #ebf4ff, #bee3f8);
            color: #2b6cb0;
        }

        .option.correct {
            border-color: #48bb78;
            background: linear-gradient(145deg, #f0fff4, #c6f6d5);
            color: #22543d;
        }

        .option.incorrect {
            border-color: #f56565;
            background: linear-gradient(145deg, #fff5f5, #fed7d7);
            color: #742a2a;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
        }

        .result-card {
            text-align: center;
            padding: 40px;
        }

        .score-display {
            font-size: 4rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 20px;
        }

        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-item {
            background: linear-gradient(145deg, #f0f4f8, #d9e2ec);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #2d3748;
        }

        .stat-label {
            color: #718096;
            margin-top: 5px;
        }

        .wrong-answers {
            text-align: left;
            margin-top: 30px;
        }

        .wrong-question {
            background: #fff5f5;
            border-left: 4px solid #f56565;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
        }

        .modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            text-align: center;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .container {
                padding: 15px;
            }
            
            .card {
                padding: 20px;
            }
            
            .controls {
                flex-direction: column;
                gap: 15px;
            }
            
            .question-header {
                flex-direction: column;
                gap: 15px;
            }
        }

        .hidden {
            display: none;
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎓 방송통신대학교</h1>
            <p>컴퓨터과학과 시험 대비 시스템</p>
        </div>

        <!-- 메인 화면 -->
        <div id="mainScreen" class="fade-in">
            <div class="card">
                <h2 style="text-align: center; margin-bottom: 30px; color: #2d3748;">📚 과목 선택</h2>
                <div class="subject-grid">
                    <div class="subject-card" onclick="startExam('computer')">
                        <h3>💻 컴퓨터의이해</h3>
                        <p>5장~13장 (20문제)</p>
                        <div class="subject-stats">
                            <span>최고점수: <span id="computer-best">0</span>점</span>
                            <span>응시횟수: <span id="computer-count">0</span>회</span>
                        </div>
                    </div>
                    <div class="subject-card" onclick="startExam('ubiquitous')">
                        <h3>🌐 유비쿼터스컴퓨팅개론</h3>
                        <p>교재 전체 (20문제)</p>
                        <div class="subject-stats">
                            <span>최고점수: <span id="ubiquitous-best">0</span>점</span>
                            <span>응시횟수: <span id="ubiquitous-count">0</span>회</span>
                        </div>
                    </div>
                    <div class="subject-card" onclick="startExam('python')">
                        <h3>🐍 파이썬프로그래밍기초</h3>
                        <p>멀티미디어 강의 전체 (20문제)</p>
                        <div class="subject-stats">
                            <span>최고점수: <span id="python-best">0</span>점</span>
                            <span>응시횟수: <span id="python-count">0</span>회</span>
                        </div>
                    </div>
                    <div class="subject-card" onclick="startExam('html')">
                        <h3>🌍 HTML5웹프로그래밍</h3>
                        <p>1~7장, 강의 1~15강 (20문제)</p>
                        <div class="subject-stats">
                            <span>최고점수: <span id="html-best">0</span>점</span>
                            <span>응시횟수: <span id="html-count">0</span>회</span>
                        </div>
                    </div>
                    <div class="subject-card" onclick="startExam('java')">
                        <h3>☕ Java프로그래밍</h3>
                        <p>교재 전체 (20문제)</p>
                        <div class="subject-stats">
                            <span>최고점수: <span id="java-best">0</span>점</span>
                            <span>응시횟수: <span id="java-count">0</span>회</span>
                        </div>
                    </div>
                    <div class="subject-card" onclick="startExam('mixed')">
                        <h3>🎯 종합시험</h3>
                        <p>전 과목 랜덤 (20문제)</p>
                        <div class="subject-stats">
                            <span>최고점수: <span id="mixed-best">0</span>점</span>
                            <span>응시횟수: <span id="mixed-count">0</span>회</span>
                        </div>
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn btn-secondary" onclick="showWrongAnswers()">📝 오답노트 보기</button>
                    <button class="btn btn-danger" onclick="resetAllData()">🗑️ 데이터 초기화</button>
                </div>
            </div>
        </div>

        <!-- 시험 화면 -->
        <div id="examScreen" class="hidden">
            <div class="question-container">
                <div class="question-header">
                    <div class="question-info">
                        <span id="currentSubject"></span> | 
                        문제 <span id="currentQuestionNum">1</span> / <span id="totalQuestions">20</span>
                    </div>
                    <div class="timer" id="timer">30:00</div>
                </div>
                
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                
                <div class="question-text" id="questionText"></div>
                <div class="question-code" id="questionCode" style="display: none;"></div>
                <div class="options" id="optionsContainer"></div>
                
                <div class="controls">
                    <button class="btn btn-secondary" onclick="previousQuestion()">◀ 이전</button>
                    <button class="btn" id="nextBtn" onclick="nextQuestion()">다음 ▶</button>
                    <button class="btn btn-danger" onclick="finishExam()">시험 종료</button>
                </div>
            </div>
        </div>

        <!-- 결과 화면 -->
        <div id="resultScreen" class="hidden">
            <div class="card result-card">
                <h2>🎉 시험 완료!</h2>
                <div class="score-display" id="finalScore">0점</div>
                
                <div class="result-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="correctCount">0</div>
                        <div class="stat-label">정답</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="incorrectCount">0</div>
                        <div class="stat-label">오답</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="accuracy">0%</div>
                        <div class="stat-label">정답률</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="timeUsed">0분</div>
                        <div class="stat-label">소요시간</div>
                    </div>
                </div>

                <div class="wrong-answers" id="wrongAnswersContainer" style="display: none;">
                    <h3>❌ 틀린 문제들</h3>
                    <div id="wrongQuestionsList"></div>
                </div>

                <div style="margin-top: 30px;">
                    <button class="btn" onclick="restartExam()">🔄 다시 시험</button>
                    <button class="btn btn-secondary" onclick="reviewWrongAnswers()">📖 틀린 문제 복습</button>
                    <button class="btn btn-secondary" onclick="goHome()">🏠 홈으로</button>
                </div>
            </div>
        </div>

        <!-- 오답노트 화면 -->
        <div id="wrongAnswerScreen" class="hidden">
            <div class="card">
                <h2>📝 오답노트</h2>
                <div id="wrongAnswersList"></div>
                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn btn-secondary" onclick="goHome()">🏠 홈으로</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 확인 모달 -->
    <div id="confirmModal" class="modal">
        <div class="modal-content">
            <h3 id="modalTitle">확인</h3>
            <p id="modalMessage">정말로 실행하시겠습니까?</p>
            <div style="margin-top: 20px;">
                <button class="btn" onclick="confirmAction()">확인</button>
                <button class="btn btn-secondary" onclick="closeModal()" style="margin-left: 10px;">취소</button>
            </div>
        </div>
    </div>

    <script>
        // 전역 변수
        let currentSubject = '';
        let currentQuestions = [];
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let examStartTime = 0;
        let examTimer = null;
        let examTimeLimit = 30 * 60; // 30분
        let examTimeLeft = examTimeLimit;
        let confirmCallback = null;

        // 통계 데이터 (메모리 저장)
        let examStats = {
            computer: { best: 0, count: 0 },
            ubiquitous: { best: 0, count: 0 },
            python: { best: 0, count: 0 },
            html: { best: 0, count: 0 },
            java: { best: 0, count: 0 },
            mixed: { best: 0, count: 0 }
        };

        let wrongAnswersHistory = [];

        // 문제 데이터베이스
        const questionDatabase = {
            computer: [
                {
                    question: "컴퓨터의 중앙처리장치(CPU)에 대한 설명으로 올바른 것은?",
                    options: [
                        "CPU는 주로 데이터를 영구적으로 저장하는 역할을 담당한다",
                        "제어장치와 연산장치로 구성되어 있다",
                        "보조기억장치의 일종이다",
                        "입력된 데이터를 화면에 출력하는 역할을 한다"
                    ],
                    correct: 1,
                    explanation: "CPU는 제어장치(Control Unit)와 연산장치(ALU)로 구성되어 있습니다."
                },
                {
                    question: "다음 중 입력장치가 아닌 것은?",
                    options: ["키보드", "마우스", "스피커", "터치패드"],
                    correct: 2,
                    explanation: "스피커는 소리를 출력하는 출력장치입니다."
                },
                {
                    question: "주기억장치(RAM)의 특징으로 올바른 것은?",
                    options: [
                        "전원이 꺼져도 데이터가 보존된다",
                        "보조기억장치보다 용량이 크다",
                        "휘발성 메모리이다",
                        "순차접근 방식으로 데이터를 읽는다"
                    ],
                    correct: 2,
                    explanation: "RAM은 전원이 꺼지면 데이터가 사라지는 휘발성 메모리입니다."
                },
                {
                    question: "다음 중 보조기억장치에 해당하는 것은?",
                    options: ["RAM", "ROM", "캐시메모리", "하드디스크"],
                    correct: 3,
                    explanation: "하드디스크는 데이터를 영구적으로 저장하는 보조기억장치입니다."
                },
                {
                    question: "QR코드에 대한 설명으로 틀린 것은?",
                    options: [
                        "2차원 바코드의 일종이다",
                        "Quick Response의 줄임말이다",
                        "1차원 바코드보다 적은 정보를 저장한다",
                        "스마트폰으로 쉽게 읽을 수 있다"
                    ],
                    correct: 2,
                    explanation: "QR코드는 1차원 바코드보다 훨씬 많은 정보를 저장할 수 있습니다."
                },
                {
                    question: "컴퓨터 네트워크의 종류 중 가장 넓은 범위를 갖는 것은?",
                    options: ["LAN", "MAN", "WAN", "PAN"],
                    correct: 2,
                    explanation: "WAN(Wide Area Network)은 가장 넓은 지역을 연결하는 네트워크입니다."
                },
                {
                    question: "인터넷 프로토콜 중 웹페이지 전송에 주로 사용되는 것은?",
                    options: ["FTP", "HTTP", "SMTP", "POP3"],
                    correct: 1,
                    explanation: "HTTP(HyperText Transfer Protocol)는 웹페이지 전송을 위한 프로토콜입니다."
                },
                {
                    question: "다음 중 시스템 소프트웨어에 해당하는 것은?",
                    options: ["워드프로세서", "웹브라우저", "운영체제", "게임"],
                    correct: 2,
                    explanation: "운영체제는 컴퓨터 시스템을 관리하는 시스템 소프트웨어입니다."
                },
                {
                    question: "데이터베이스 관리시스템(DBMS)의 주요 기능이 아닌 것은?",
                    options: ["데이터 정의", "데이터 조작", "데이터 제어", "데이터 압축"],
                    correct: 3,
                    explanation: "DBMS의 주요 기능은 데이터 정의, 조작, 제어이며, 압축은 부가 기능입니다."
                },
                {
                    question: "컴퓨터 바이러스에 대한 설명으로 틀린 것은?",
                    options: [
                        "자기복제 능력을 갖는다",
                        "다른 프로그램에 기생한다",
                        "하드웨어만 감염시킨다",
                        "예방을 위해 백신 프로그램을 사용한다"
                    ],
                    correct: 2,
                    explanation: "컴퓨터 바이러스는 소프트웨어를 감염시키며, 하드웨어를 직접 감염시키지는 않습니다."
                },
                {
                    question: "하드디스크는 주기억장치에 속한다.",
                    type: "ox",
                    correct: false,
                    explanation: "하드디스크는 보조기억장치입니다."
                },
                {
                    question: "URL은 Uniform Resource Locator의 줄임말이다.",
                    type: "ox",
                    correct: true,
                    explanation: "URL은 Uniform Resource Locator의 줄임말이 맞습니다."
                },
                {
                    question: "컴파일러는 고급언어를 기계어로 번역하는 프로그램이다.",
                    type: "ox",
                    correct: true,
                    explanation: "컴파일러는 고급언어를 기계어로 번역하는 번역 프로그램입니다."
                },
                {
                    question: "TCP/IP는 인터넷의 표준 프로토콜이다.",
                    type: "ox",
                    correct: true,
                    explanation: "TCP/IP는 인터넷에서 사용되는 표준 통신 프로토콜입니다."
                },
                {
                    question: "폰 노이만 구조에서는 프로그램과 데이터가 같은 메모리에 저장된다.",
                    type: "ox",
                    correct: true,
                    explanation: "폰 노이만 구조의 특징은 프로그램과 데이터가 동일한 메모리에 저장되는 것입니다."
                },
                {
                    question: "클라우드 컴퓨팅의 특징으로 올바른 것은?",
                    options: [
                        "개인 컴퓨터에만 데이터를 저장한다",
                        "인터넷을 통해 컴퓨팅 자원을 제공받는다",
                        "오프라인에서만 사용 가능하다",
                        "하드웨어 구매가 필수적이다"
                    ],
                    correct: 1,
                    explanation: "클라우드 컴퓨팅은 인터넷을 통해 컴퓨팅 자원을 서비스로 제공받는 기술입니다."
                },
                {
                    question: "정보보안의 3요소가 아닌 것은?",
                    options: ["기밀성(Confidentiality)", "무결성(Integrity)", "가용성(Availability)", "호환성(Compatibility)"],
                    correct: 3,
                    explanation: "정보보안의 3요소는 기밀성, 무결성, 가용성입니다."
                },
                {
                    question: "멀티미디어 데이터 중 용량이 가장 큰 것은?",
                    options: ["텍스트", "이미지", "오디오", "비디오"],
                    correct: 3,
                    explanation: "비디오는 이미지와 오디오를 포함하므로 가장 큰 용량을 차지합니다."
                },
                {
                    question: "다음 중 프로그래밍 언어가 아닌 것은?",
                    options: ["Java", "Python", "HTML", "C++"],
                    correct: 2,
                    explanation: "HTML은 마크업 언어이며, 프로그래밍 언어가 아닙니다."
                },
                {
                    question: "인공지능(AI)의 분야가 아닌 것은?",
                    options: ["기계학습", "자연어처리", "컴퓨터비전", "하드웨어설계"],
                    correct: 3,
                    explanation: "하드웨어설계는 인공지능의 연구 분야가 아닙니다."
                }
            ],
            ubiquitous: [
                {
                    question: "유비쿼터스 혁명이 만들어내는 공간으로 옳은 것은?",
                    options: ["유비쿼터스 공간", "사이버 공간", "물리공간", "가상 공간"],
                    correct: 0,
                    explanation: "유비쿼터스 혁명은 물리공간과 사이버공간이 융합된 유비쿼터스 공간을 만들어냅니다."
                },
                {
                    question: "유비쿼터스 컴퓨팅의 특징이 아닌 것은?",
                    options: [
                        "사물내의 컴퓨터의 내재화",
                        "사람-사물-컴퓨터 유기적 연결",
                        "모든 사물의 지능화",
                        "가상공간과 사이버공간의 융합"
                    ],
                    correct: 3,
                    explanation: "유비쿼터스 컴퓨팅은 물리공간과 사이버공간의 융합이 특징입니다."
                },
                {
                    question: "MEMS 기술의 특징인 것은?",
                    options: ["단편적 기술", "단일 산업 분야와의 연계", "부품의 평면성", "기술의 융합성"],
                    correct: 3,
                    explanation: "MEMS는 기계, 전자, 재료 등 여러 기술이 융합된 기술입니다."
                },
                {
                    question: "디지털 콘텐츠의 불법복제에 따른 문제를 해결하고 저작권자의 권리를 보호하기 위해서 제안된 기술은?",
                    options: ["RFID", "DRM", "HCI 기술", "생체인식 기술"],
                    correct: 1,
                    explanation: "DRM(Digital Rights Management)은 디지털 저작권 관리 기술입니다."
                },
                {
                    question: "사람의 기본적인 의사소통 수단인 '말(언어)'을 통해 보다 편리하고 인간적인 방식의 컴퓨팅 환경을 구축하기 위한 기반 기술은?",
                    options: ["음성인식 기술", "홍채인식 기술", "음성합성 기술", "안면인식 기술"],
                    correct: 0,
                    explanation: "음성인식 기술은 사람의 음성을 컴퓨터가 이해할 수 있도록 하는 기술입니다."
                },
                {
                    question: "RFID 시스템 구성 요소에 포함되지 않는 것은?",
                    options: [
                        "무선 송수신용 안테나를 내장한 리더(Reader)",
                        "필요한 정보를 저장하고 교환하는 태그",
                        "무선 충전기술",
                        "유․무선 통신망으로 연결된 서버"
                    ],
                    correct: 2,
                    explanation: "RFID 시스템은 리더, 태그, 통신망으로 구성되며 무선 충전기술은 포함되지 않습니다."
                },
                {
                    question: "칩 자체가 하나의 시스템으로 기능할 수 있도록 마이크로 프로세서와 디지털 신호 처리 장치, 메모리, 베이스밴드 칩, 임베디드 소프트웨어 등을 집적시킨 칩은?",
                    options: ["RFID", "ZigBee", "NFC", "SoC (system on chip)"],
                    correct: 3,
                    explanation: "SoC는 하나의 칩에 시스템 전체 기능을 집적한 기술입니다."
                },
                {
                    question: "IoT 플랫폼이 갖추어야 할 기능이 아닌 것은?",
                    options: [
                        "이기종 센서들에 대한 식별 및 연결 기능",
                        "각 사물에 대한 제어 기능",
                        "웹을 통한 폐쇄형 서비스 제공 기능",
                        "수집된 대용량 데이터에 대한 효율적인 검색 및 분석 기능"
                    ],
                    correct: 2,
                    explanation: "IoT 플랫폼은 개방형 서비스를 제공해야 하며, 폐쇄형은 적합하지 않습니다."
                },
                {
                    question: "다음 중 충전이 아닌 연료를 공급함으로써 지속적인 전기 생산이 가능한 전지는?",
                    options: ["납축전지", "태양전지", "연료전지", "대용량 커패시터"],
                    correct: 2,
                    explanation: "연료전지는 수소와 산소의 화학반응으로 지속적으로 전기를 생산합니다."
                },
                {
                    question: "유비쿼터스 네트워크에서 서버상의 콘텐츠 같은 객체로 연결성 제공 및 서비스를 위한 객체는?",
                    options: ["환경 사물", "고정 사물", "이동 사물", "논리적 사물"],
                    correct: 3,
                    explanation: "논리적 사물은 소프트웨어적으로 구현된 가상의 객체를 말합니다."
                },
                {
                    question: "다음 중 RFID의 특징이 아닌 것은?",
                    options: [
                        "데이터의 위조 및 변조가 불가능하다",
                        "바코드에 비해 가격이 높다",
                        "바코드에 비해 많은 정보의 축적이 가능하다",
                        "바코드나 스마트카드에 비해서 활용 범위나 적용 분야가 좁다"
                    ],
                    correct: 3,
                    explanation: "RFID는 바코드보다 활용 범위와 적용 분야가 넓습니다."
                },
                {
                    question: "유비쿼터스 센서 네트워크의 계층구조에 포함되지 않는 것은?",
                    options: [
                        "USN 응용 서비스 계층",
                        "USN 미들웨어 계층",
                        "BcN 백본 및 접속 네트워크 계층",
                        "센서 연결 계층"
                    ],
                    correct: 3,
                    explanation: "USN 계층구조에는 응용 서비스, 미들웨어, 백본 네트워크 계층이 포함됩니다."
                },
                {
                    question: "센서 네트워크 내의 모든 센서 노드에서 센싱된 데이터를 수집하는 노드는?",
                    options: ["싱크노드", "단말노드", "센서노드", "루트노드"],
                    correct: 0,
                    explanation: "싱크노드는 센서 네트워크에서 데이터를 수집하는 중앙 노드입니다."
                },
                {
                    question: "RFID에서 정보보호 방안중에서 금속성의 그물(mesh)이나 박막(foil)을 입혀 무선 주파수가 침투하지 못하도록 하는 것은?",
                    options: [
                        "킬 태그(Kill Tag)",
                        "페러데이 케이지(Faraday Cage)",
                        "방해 전파(Active Jamming)",
                        "차단자 태그(Blocker Tag)"
                    ],
                    correct: 1,
                    explanation: "페러데이 케이지는 전자기파를 차단하는 금속 울타리 구조입니다."
                },
                {
                    question: "상황 인식 시스템에서 상황정보 모델링 방법중에서 태그, 속성 그리고 내용을 계층구조로 나타내어 재귀적 형태로 상황정보를 표현하는 것은?",
                    options: [
                        "온톨로지 기반 모델",
                        "마크 업 기반 모델",
                        "키값 기반 모델",
                        "인덱스 기반 모델"
                    ],
                    correct: 1,
                    explanation: "마크업 기반 모델은 XML과 같은 태그 구조로 정보를 표현합니다."
                },
                {
                    question: "컴퓨터가 사람의 일상 언어를 이해하고 생성할 수 있도록 함으로써 인간의 지적 활동의 보조자 및 지원 도구로 활용하고자 하는 기술은?",
                    options: [
                        "음성 합성 기술",
                        "자연어 처리 기술",
                        "음성 분석 기술",
                        "정보 처리 기술"
                    ],
                    correct: 1,
                    explanation: "자연어 처리 기술은 컴퓨터가 인간의 언어를 이해하고 처리하는 기술입니다."
                },
                {
                    question: "착용 컴퓨팅 기술의 기본 기능이 아닌 것은?",
                    options: ["착용감", "항시성", "정숙성", "안정성"],
                    correct: 2,
                    explanation: "착용 컴퓨팅의 기본 기능은 착용감, 항시성, 안정성입니다."
                },
                {
                    question: "u-시티의 특성이 아닌 것은?",
                    options: [
                        "정보중심의 도시",
                        "효율적 도시관리 기능",
                        "인구, 교통, 업무의 중앙화",
                        "자급자족의 친환경 도시"
                    ],
                    correct: 2,
                    explanation: "u-시티는 분산화된 도시 구조를 지향합니다."
                },
                {
                    question: "u-시티 네트워크를 활용하여 u-시티의 각종 스마트 시설 및 u-시티 서비스를 실시간으로 관리 및 제어하는 기능을 수행하는 것은?",
                    options: [
                        "u-시티 통합 단말기",
                        "u-시티 네트워크",
                        "u-시티 서비스 플랫폼",
                        "u-시티 운영센터"
                    ],
                    correct: 3,
                    explanation: "u-시티 운영센터는 도시 전체를 통합 관리하는 중앙 시설입니다."
                },
                {
                    question: "유비쿼터스 컴퓨팅의 특징으로 올바른 것은?",
                    options: [
                        "컴퓨터가 항상 눈에 보이는 곳에 위치한다",
                        "언제 어디서나 네트워크에 접속할 수 있다",
                        "한 번에 하나의 작업만 처리할 수 있다",
                        "사용자가 직접 컴퓨터를 조작해야만 동작한다"
                    ],
                    correct: 1,
                    explanation: "유비쿼터스 컴퓨팅은 언제 어디서나 접근 가능한 컴퓨팅 환경을 의미합니다."
                },
                {
                    question: "IoT(Internet of Things)에 대한 설명으로 틀린 것은?",
                    options: [
                        "사물인터넷이라고도 한다",
                        "다양한 사물들이 인터넷에 연결되어 정보를 주고받는다",
                        "센서와 통신 기능이 필요하다",
                        "인터넷 없이도 완전히 독립적으로 동작한다"
                    ],
                    correct: 3,
                    explanation: "IoT는 인터넷을 통해 사물들이 연결되어 정보를 주고받는 기술입니다."
                },
                {
                    question: "스마트홈의 구성요소가 아닌 것은?",
                    options: ["센서", "홈 게이트웨이", "스마트 가전제품", "진공관"],
                    correct: 3,
                    explanation: "진공관은 스마트홈과 관련이 없는 구식 전자부품입니다."
                },
                {
                    question: "RFID 시스템의 구성요소가 아닌 것은?",
                    options: ["RFID 태그", "RFID 리더", "안테나", "모니터"],
                    correct: 3,
                    explanation: "RFID 시스템은 태그, 리더, 안테나로 구성되며 모니터는 필수 구성요소가 아닙니다."
                },
                {
                    question: "센서네트워크의 특징으로 틀린 것은?",
                    options: [
                        "무선 통신을 사용한다",
                        "배터리로 동작하는 경우가 많다",
                        "대용량 데이터 처리에 최적화되어 있다",
                        "환경 모니터링에 활용된다"
                    ],
                    correct: 2,
                    explanation: "센서네트워크는 저전력 환경에서 동작하므로 대용량 데이터 처리에는 최적화되어 있지 않습니다."
                },
                {
                    question: "모바일 컴퓨팅의 특징이 아닌 것은?",
                    options: ["이동성", "휴대성", "무선 연결성", "고정성"],
                    correct: 3,
                    explanation: "모바일 컴퓨팅의 특징은 이동성, 휴대성, 무선 연결성이며 고정성은 반대 개념입니다."
                },
                {
                    question: "위치기반 서비스(LBS)에서 사용되는 기술이 아닌 것은?",
                    options: ["GPS", "WiFi", "블루투스", "적외선 통신"],
                    correct: 3,
                    explanation: "LBS에서는 GPS, WiFi, 블루투스 등이 사용되며 적외선 통신은 거리 제한이 있어 부적합합니다."
                },
                {
                    question: "웨어러블 컴퓨팅 기기의 예가 아닌 것은?",
                    options: ["스마트워치", "스마트글래스", "피트니스 밴드", "데스크톱 컴퓨터"],
                    correct: 3,
                    explanation: "데스크톱 컴퓨터는 착용할 수 없는 고정형 컴퓨터입니다."
                },
                {
                    question: "상황인식 컴퓨팅에서 고려되는 컨텍스트가 아닌 것은?",
                    options: ["위치", "시간", "사용자 신원", "컴퓨터 브랜드"],
                    correct: 3,
                    explanation: "상황인식 컴퓨팅에서는 위치, 시간, 사용자 정보 등이 중요하며 브랜드는 관련 없습니다."
                },
                {
                    question: "스마트 시티의 구성요소가 아닌 것은?",
                    options: ["지능형 교통 시스템", "스마트 그리드", "u-헬스케어", "수동 관리 시스템"],
                    correct: 3,
                    explanation: "스마트 시티는 지능형 시스템들로 구성되며 수동 관리 시스템은 스마트 시티의 개념에 맞지 않습니다."
                },
                {
                    question: "유비쿼터스 컴퓨팅에서는 컴퓨터가 사용자에게 보이지 않게 숨겨져 있다.",
                    type: "ox",
                    correct: true,
                    explanation: "유비쿼터스의 특징 중 하나는 컴퓨터가 환경에 자연스럽게 숨겨져 있는 것입니다."
                },
                {
                    question: "RFID는 Radio Frequency Identification의 줄임말이다.",
                    type: "ox",
                    correct: true,
                    explanation: "RFID는 Radio Frequency Identification의 줄임말이 맞습니다."
                },
                {
                    question: "NFC는 근거리 무선 통신 기술이다.",
                    type: "ox",
                    correct: true,
                    explanation: "NFC(Near Field Communication)는 근거리 무선 통신 기술입니다."
                },
                {
                    question: "유비쿼터스 환경에서는 개인정보 보호 문제가 발생하지 않는다.",
                    type: "ox",
                    correct: false,
                    explanation: "유비쿼터스 환경에서는 오히려 개인정보 보호 문제가 더욱 중요해집니다."
                },
                {
                    question: "스마트폰은 유비쿼터스 컴퓨팅의 대표적인 사례이다.",
                    type: "ox",
                    correct: true,
                    explanation: "스마트폰은 언제 어디서나 사용할 수 있는 유비쿼터스 컴퓨팅의 대표적인 사례입니다."
                },
                {
                    question: "M2M(Machine to Machine) 통신의 특징으로 올바른 것은?",
                    options: [
                        "사람의 개입이 반드시 필요하다",
                        "기계 간 자동 통신이다",
                        "유선 통신만 사용한다",
                        "실시간 처리가 불가능하다"
                    ],
                    correct: 1,
                    explanation: "M2M은 기계와 기계 간의 자동 통신을 의미합니다."
                },
                {
                    question: "클라우드 컴퓨팅 서비스 모델이 아닌 것은?",
                    options: ["SaaS", "PaaS", "IaaS", "HaaS"],
                    correct: 3,
                    explanation: "클라우드 서비스 모델은 SaaS, PaaS, IaaS이며 HaaS는 표준 모델이 아닙니다."
                },
                {
                    question: "빅데이터의 특징을 나타내는 3V가 아닌 것은?",
                    options: ["Volume (크기)", "Velocity (속도)", "Variety (다양성)", "Vision (비전)"],
                    correct: 3,
                    explanation: "빅데이터의 3V는 Volume, Velocity, Variety입니다."
                },
                {
                    question: "증강현실(AR)과 가상현실(VR)의 차이점으로 올바른 것은?",
                    options: [
                        "AR은 현실 세계에 가상 정보를 합성한다",
                        "VR은 현실 세계를 완전히 대체한다",
                        "AR은 완전 몰입형 환경을 제공한다",
                        "①, ②번 모두 올바르다"
                    ],
                    correct: 3,
                    explanation: "AR은 현실에 가상 정보를 합성하고, VR은 현실을 완전히 대체합니다."
                },
                {
                    question: "스마트 그리드의 특징이 아닌 것은?",
                    options: ["양방향 통신", "지능형 전력망", "단방향 전력 공급", "신재생 에너지 통합"],
                    correct: 2,
                    explanation: "스마트 그리드는 양방향 통신과 지능형 제어가 특징입니다."
                }
            ],
            python: [
                {
                    question: "파이썬에서 변수를 선언할 때 올바른 방법은?",
                    options: ["int x = 10;", "var x = 10", "x = 10", "declare x = 10"],
                    correct: 2,
                    explanation: "파이썬에서는 변수명 = 값 형태로 간단히 선언합니다."
                },
                {
                    question: "다음 중 파이썬의 기본 데이터 타입이 아닌 것은?",
                    options: ["int", "float", "bool", "char"],
                    correct: 3,
                    explanation: "파이썬에는 char 타입이 없으며, 문자는 길이가 1인 문자열로 처리합니다."
                },
                {
                    question: "파이썬에서 리스트의 첫 번째 요소를 가져오는 방법은?",
                    options: ["list[1]", "list[0]", "list.first()", "list.get(1)"],
                    correct: 1,
                    explanation: "파이썬의 인덱스는 0부터 시작하므로 list[0]으로 첫 번째 요소에 접근합니다."
                },
                {
                    question: "다음 코드의 실행 결과는?\n```python\nx = [1, 2, 3, 4, 5]\nprint(len(x))\n```",
                    options: ["4", "5", "6", "오류 발생"],
                    correct: 1,
                    explanation: "len() 함수는 리스트의 요소 개수를 반환하므로 5가 출력됩니다."
                },
                {
                    question: "파이썬에서 문자열을 나타내는 방법이 아닌 것은?",
                    options: ["\"Hello\"", "'Hello'", "\"\"\"Hello\"\"\"", "<Hello>"],
                    correct: 3,
                    explanation: "파이썬에서는 <> 기호로 문자열을 나타낼 수 없습니다."
                },
                {
                    question: "다음 중 파이썬의 반복문이 아닌 것은?",
                    options: ["for", "while", "do-while", "①, ②번 모두 반복문이다"],
                    correct: 2,
                    explanation: "파이썬에는 do-while 반복문이 없습니다."
                },
                {
                    question: "파이썬에서 주석을 작성하는 방법은?",
                    options: ["// 주석", "/* 주석 */", "# 주석", "<!-- 주석 -->"],
                    correct: 2,
                    explanation: "파이썬에서는 # 기호를 사용하여 주석을 작성합니다."
                },
                {
                    question: "다음 코드의 실행 결과는?\n```python\nx = 10\ny = 3\nprint(x // y)\n```",
                    options: ["3.33", "3", "4", "1"],
                    correct: 1,
                    explanation: "// 연산자는 정수 나눗셈(몫)을 수행하므로 3이 출력됩니다."
                },
                {
                    question: "파이썬에서 함수를 정의할 때 사용하는 키워드는?",
                    options: ["function", "def", "func", "define"],
                    correct: 1,
                    explanation: "파이썬에서는 def 키워드를 사용하여 함수를 정의합니다."
                },
                {
                    question: "다음 코드의 실행 결과는?\n```python\ntext = \"Python\"\nprint(text[1:4])\n```",
                    options: ["Pyt", "yth", "ytho", "thon"],
                    correct: 1,
                    explanation: "문자열 슬라이싱에서 text[1:4]는 인덱스 1부터 3까지(4 미포함)를 의미하므로 'yth'가 출력됩니다."
                },
                {
                    question: "파이썬에서 들여쓰기(indentation)는 코드 블록을 구분하는 데 사용된다.",
                    type: "ox",
                    correct: true,
                    explanation: "파이썬은 들여쓰기로 코드 블록을 구분하는 언어입니다."
                },
                {
                    question: "파이썬은 컴파일 언어이다.",
                    type: "ox",
                    correct: false,
                    explanation: "파이썬은 인터프리터 언어입니다."
                },
                {
                    question: "파이썬에서 변수명은 숫자로 시작할 수 있다.",
                    type: "ox",
                    correct: false,
                    explanation: "파이썬 변수명은 숫자로 시작할 수 없습니다."
                },
                {
                    question: "파이썬은 객체지향 프로그래밍을 지원한다.",
                    type: "ox",
                    correct: true,
                    explanation: "파이썬은 객체지향 프로그래밍을 완전히 지원합니다."
                },
                {
                    question: "파이썬에서 리스트는 서로 다른 데이터 타입의 요소를 포함할 수 있다.",
                    type: "ox",
                    correct: true,
                    explanation: "파이썬 리스트는 서로 다른 데이터 타입의 요소를 포함할 수 있습니다."
                },
                {
                    question: "파이썬에서 딕셔너리를 생성하는 올바른 방법은?",
                    options: ["dict = [key: value]", "dict = {key: value}", "dict = (key: value)", "dict = <key: value>"],
                    correct: 1,
                    explanation: "파이썬에서 딕셔너리는 중괄호 {}를 사용하여 생성합니다."
                },
                {
                    question: "다음 중 파이썬의 조건문에서 사용되지 않는 키워드는?",
                    options: ["if", "elif", "else", "switch"],
                    correct: 3,
                    explanation: "파이썬에는 switch 문이 없습니다."
                },
                {
                    question: "파이썬에서 모듈을 import하는 올바른 방법은?",
                    options: ["include math", "import math", "using math", "require math"],
                    correct: 1,
                    explanation: "파이썬에서는 import 키워드를 사용하여 모듈을 가져옵니다."
                },
                {
                    question: "다음 코드의 실행 결과는?\n```python\nnumbers = [1, 2, 3]\nnumbers.append(4)\nprint(numbers)\n```",
                    options: ["[1, 2, 3]", "[1, 2, 3, 4]", "[4, 1, 2, 3]", "오류 발생"],
                    correct: 1,
                    explanation: "append() 메소드는 리스트의 끝에 요소를 추가합니다."
                },
                {
                    question: "파이썬에서 예외처리에 사용되는 키워드 조합으로 올바른 것은?",
                    options: ["try-catch", "try-except", "begin-rescue", "attempt-handle"],
                    correct: 1,
                    explanation: "파이썬에서는 try-except 구문을 사용하여 예외를 처리합니다."
                }
            ],
            html: [
                {
                    question: "HTML5에서 새롭게 추가된 시맨틱 태그가 아닌 것은?",
                    options: ["<article>", "<section>", "<nav>", "<font>"],
                    correct: 3,
                    explanation: "<font> 태그는 HTML5에서 권장되지 않는 태그입니다."
                },
                {
                    question: "CSS에서 클래스 선택자를 나타내는 기호는?",
                    options: ["#", ".", "*", "&"],
                    correct: 1,
                    explanation: "CSS에서 클래스 선택자는 점(.) 기호를 사용합니다."
                },
                {
                    question: "HTML 문서의 기본 구조로 올바른 것은?",
                    options: ["<html> - <head> - <body>", "<body> - <head> - <html>", "<head> - <html> - <body>", "<html> - <body> - <head>"],
                    correct: 0,
                    explanation: "HTML 문서는 html 태그 안에 head와 body 태그가 순서대로 위치합니다."
                },
                {
                    question: "JavaScript에서 HTML 요소를 선택하는 메소드는?",
                    options: ["selectElement()", "getElementById()", "findElement()", "chooseElement()"],
                    correct: 1,
                    explanation: "getElementById()는 ID로 HTML 요소를 선택하는 메소드입니다."
                },
                {
                    question: "HTML5에서 비디오를 재생하기 위한 태그는?",
                    options: ["<media>", "<video>", "<movie>", "<play>"],
                    correct: 1,
                    explanation: "HTML5의 <video> 태그를 사용하여 비디오를 재생할 수 있습니다."
                },
                {
                    question: "CSS의 박스 모델 구성요소가 아닌 것은?",
                    options: ["content", "padding", "border", "background"],
                    correct: 3,
                    explanation: "CSS 박스 모델은 content, padding, border, margin으로 구성됩니다."
                },
                {
                    question: "HTML에서 하이퍼링크를 만들 때 사용하는 태그는?",
                    options: ["<link>", "<a>", "<href>", "<url>"],
                    correct: 1,
                    explanation: "<a> 태그를 사용하여 하이퍼링크를 만듭니다."
                },
                {
                    question: "JavaScript에서 변수를 선언하는 키워드가 아닌 것은?",
                    options: ["var", "let", "const", "variable"],
                    correct: 3,
                    explanation: "JavaScript에서는 var, let, const를 사용하여 변수를 선언합니다."
                },
                {
                    question: "HTML5에서 입력 폼을 만들 때 사용하는 태그는?",
                    options: ["<input>", "<form>", "<field>", "①, ②번 모두 사용"],
                    correct: 3,
                    explanation: "<form> 태그 안에 <input> 태그를 사용하여 입력 폼을 만듭니다."
                },
                {
                    question: "CSS에서 텍스트 색상을 지정하는 속성은?",
                    options: ["text-color", "font-color", "color", "text-style"],
                    correct: 2,
                    explanation: "CSS에서는 color 속성을 사용하여 텍스트 색상을 지정합니다."
                },
                {
                    question: "HTML 문서는 반드시 <!DOCTYPE html>로 시작해야 한다.",
                    type: "ox",
                    correct: true,
                    explanation: "HTML5 문서는 <!DOCTYPE html>로 시작해야 합니다."
                },
                {
                    question: "CSS는 Cascading Style Sheets의 줄임말이다.",
                    type: "ox",
                    correct: true,
                    explanation: "CSS는 Cascading Style Sheets의 줄임말이 맞습니다."
                },
                {
                    question: "JavaScript는 클라이언트 사이드에서만 실행된다.",
                    type: "ox",
                    correct: false,
                    explanation: "JavaScript는 Node.js를 통해 서버 사이드에서도 실행할 수 있습니다."
                },
                {
                    question: "HTML5에서는 Flash 플러그인 없이도 비디오와 오디오를 재생할 수 있다.",
                    type: "ox",
                    correct: true,
                    explanation: "HTML5는 네이티브로 비디오와 오디오 재생을 지원합니다."
                },
                {
                    question: "CSS에서 ID 선택자는 #기호로 시작한다.",
                    type: "ox",
                    correct: true,
                    explanation: "CSS에서 ID 선택자는 # 기호로 시작합니다."
                },
                {
                    question: "HTML5의 Canvas 요소로 할 수 있는 작업이 아닌 것은?",
                    options: ["그래픽 그리기", "애니메이션 구현", "데이터베이스 연동", "이미지 조작"],
                    correct: 2,
                    explanation: "Canvas는 그래픽 작업에 사용되며 데이터베이스 연동은 서버 사이드에서 처리됩니다."
                },
                {
                    question: "JavaScript에서 배열을 선언하는 올바른 방법은?",
                    options: ["array = [1, 2, 3]", "array = (1, 2, 3)", "array = {1, 2, 3}", "array = <1, 2, 3>"],
                    correct: 0,
                    explanation: "JavaScript에서는 대괄호 []를 사용하여 배열을 선언합니다."
                },
                {
                    question: "HTML5에서 오디오 파일을 재생하는 태그는?",
                    options: ["<sound>", "<music>", "<audio>", "<mp3>"],
                    correct: 2,
                    explanation: "HTML5의 <audio> 태그를 사용하여 오디오를 재생할 수 있습니다."
                },
                {
                    question: "CSS에서 요소를 숨기는 속성은?",
                    options: ["display: none", "visibility: hidden", "opacity: 0", "위의 모든 방법 가능"],
                    correct: 3,
                    explanation: "CSS에서는 display: none, visibility: hidden, opacity: 0 모두 요소를 숨기는 방법입니다."
                },
                {
                    question: "HTML5에서 로컬 스토리지를 사용하는 JavaScript 객체는?",
                    options: ["localStorage", "sessionStorage", "webStorage", "①, ②번 모두 가능"],
                    correct: 3,
                    explanation: "HTML5에서는 localStorage와 sessionStorage 모두 로컬 스토리지 기능을 제공합니다."
                }
            ],
            java: [
                {
                    question: "Java 언어의 특징으로 올바른 것은?",
                    options: ["플랫폼에 종속적이다", "포인터를 사용한다", "객체지향 프로그래밍 언어이다", "컴파일 없이 바로 실행된다"],
                    correct: 2,
                    explanation: "Java는 객체지향 프로그래밍 언어로 플랫폼 독립적이고 포인터를 사용하지 않습니다."
                },
                {
                    question: "Java에서 클래스를 정의할 때 사용하는 키워드는?",
                    options: ["define", "class", "object", "struct"],
                    correct: 1,
                    explanation: "Java에서는 class 키워드를 사용하여 클래스를 정의합니다."
                },
                {
                    question: "다음 중 Java의 기본 데이터 타입이 아닌 것은?",
                    options: ["int", "boolean", "String", "double"],
                    correct: 2,
                    explanation: "String은 참조 타입이며, 기본 데이터 타입이 아닙니다."
                },
                {
                    question: "Java에서 배열을 선언할 때 틀린 방법은?",
                    options: ["int[] array;", "int array[];", "int[5] array;", "int[][] array;"],
                    correct: 2,
                    explanation: "Java에서는 배열 선언 시 크기를 지정할 수 없습니다."
                },
                {
                    question: "Java의 main 메소드 선언으로 올바른 것은?",
                    options: ["public static void main(String args[])", "private void main(String[] args)", "public main(String[] args)", "static main(String args)"],
                    correct: 0,
                    explanation: "Java의 main 메소드는 public static void로 선언되어야 합니다."
                },
                {
                    question: "Java에서 상속을 나타내는 키워드는?",
                    options: ["inherit", "extends", "implements", "super"],
                    correct: 1,
                    explanation: "Java에서는 extends 키워드를 사용하여 상속을 구현합니다."
                },
                {
                    question: "Java의 접근 제어자가 아닌 것은?",
                    options: ["public", "private", "protected", "internal"],
                    correct: 3,
                    explanation: "Java의 접근 제어자는 public, private, protected, default(package)입니다."
                },
                {
                    question: "다음 중 Java의 반복문이 아닌 것은?",
                    options: ["for", "while", "do-while", "repeat-until"],
                    correct: 3,
                    explanation: "Java에는 repeat-until 반복문이 없습니다."
                },
                {
                    question: "Java에서 예외 처리에 사용되는 키워드가 아닌 것은?",
                    options: ["try", "catch", "finally", "handle"],
                    correct: 3,
                    explanation: "Java에서는 try-catch-finally를 사용하여 예외를 처리합니다."
                },
                {
                    question: "Java에서 추상 클래스를 선언할 때 사용하는 키워드는?",
                    options: ["abstract", "virtual", "interface", "final"],
                    correct: 0,
                    explanation: "Java에서는 abstract 키워드를 사용하여 추상 클래스를 선언합니다."
                },
                // 기출문제 추가 (총 30문제 중 20문제가 랜덤 선택됨)
                {
                    question: "Java 프로그램의 다음 코드에서 주석의 개수는 몇 개인가?\n```java\n/**\n * This is my first java program.\n */\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World\"); // prints Hello World\n    }\n}\n```",
                    options: ["1개", "2개", "3개", "4개"],
                    correct: 1,
                    explanation: "/** */ 형태의 문서 주석 1개와 // 형태의 한줄 주석 1개로 총 2개입니다."
                },
                {
                    question: "다음 Circle 클래스에서 PI 상수를 선언할 때 적절한 접근제어자는 무엇인가?\n```java\nclass Circle {\n    _______ double PI = 3.14;  // 상수\n    private double r;\n    \n    public Circle(double r) { this.r = r; }\n    void setR(double r) { this.r = r; }\n}\n```",
                    options: ["final static", "public static", "static private", "public final"],
                    correct: 1,
                    explanation: "PI는 수학 상수로 모든 클래스에서 접근 가능해야 하므로 public이고, 객체 생성 없이 사용할 수 있도록 static으로 선언합니다."
                },
                {
                    question: "다음 중 생성자의 올바른 선언 형태는 무엇인가?",
                    options: ["private Circle(double r)", "public Circle(double r)", "private void Circle(double r)", "public void Circle(double r)"],
                    correct: 1,
                    explanation: "생성자는 반환형이 없고, 클래스명과 동일한 이름을 가져야 합니다. 일반적으로 public으로 선언합니다."
                },
                {
                    question: "Java 개발환경의 구성요소가 아닌 것은 무엇인가?",
                    options: ["Java Platform", "Java VM", "JDK", "Eclipse for JavaScript"],
                    correct: 3,
                    explanation: "Eclipse for JavaScript는 Java 개발환경이 아닌 JavaScript 개발을 위한 도구입니다."
                },
                {
                    question: "배열의 선언과 초기화 중 올바르지 않은 것은?",
                    options: ["int[] a = new int[10];", "int b[] = { 1, 2, 3, 4 };", "int[] c; c = {1, 2, 3, 4};", "int[][] d = new int[10][];"],
                    correct: 2,
                    explanation: "배열을 별도로 선언한 후 초기화할 때는 new int[]{1, 2, 3, 4} 형태로 써야 합니다."
                },
                {
                    question: "int형 변수 i와 j의 값을 공백으로 구분하여 출력하는 올바른 방법은?",
                    options: ["System.out.println( i + j );", "System.out.println( i + \" \" + j );", "System.out.println( i , j );", "System.out.println( i , \"=\" , j );"],
                    correct: 1,
                    explanation: "문자열 연결 연산자(+)를 사용하여 공백(\" \")을 중간에 넣어 출력합니다."
                },
                {
                    question: "B와 C가 클래스이고 Y와 Z가 인터페이스일 때, 다음 중 문법적으로 올바른 것은?",
                    options: ["class A extends B, C { }", "class A extends B, Y { }", "class A implements Y, Z { }", "interface X extends Y, Z { }"],
                    correct: 2,
                    explanation: "클래스는 하나의 클래스만 상속받을 수 있지만(extends), 여러 인터페이스를 구현할 수 있습니다(implements)."
                },
                {
                    question: "다음 상속관계에서 부모클래스의 메소드를 자식클래스에서 재정의할 때 사용하는 접근제어자로 올바른 것은?\n```java\n// 부모클래스의 메소드\nprotected double compute(int x, int y)\n```",
                    options: ["private double compute(int x, int y)", "protected double compute(int x, int y)", "public double compute(int x, int y)", "②, ③번 모두 가능"],
                    correct: 3,
                    explanation: "메소드 오버라이딩 시 접근제어자는 부모클래스와 같거나 더 넓은 범위여야 합니다. protected → protected, public 가능합니다."
                },
                {
                    question: "Circle 클래스에서 반지름 r이 private으로 선언되어 있을 때, 외부에서 r값을 10으로 설정하는 올바른 방법은?\n```java\nCircle c = new Circle(0);\n```",
                    options: ["c.r = 10;", "c.setR(10);", "c.getR(10);", "Circle.r = 10;"],
                    correct: 1,
                    explanation: "private 멤버변수는 직접 접근할 수 없으므로 setter 메소드를 통해 값을 설정해야 합니다."
                },
                {
                    question: "Java에서 다음 중 올바른 메인 메소드 선언은?",
                    options: ["public static void main(String args)", "public static void main(String[] args)", "public void main(String[] args)", "static void main(String[] args)"],
                    correct: 1,
                    explanation: "Java의 메인 메소드는 public static void main(String[] args) 형태로 선언해야 합니다."
                },
                {
                    question: "Java는 \"Write Once, Run Anywhere\"의 특징을 갖는다.",
                    type: "ox",
                    correct: true,
                    explanation: "Java는 JVM을 통해 플랫폼 독립적으로 실행될 수 있습니다."
                },
                {
                    question: "Java에서 가비지 컬렉션은 개발자가 직접 실행해야 한다.",
                    type: "ox",
                    correct: false,
                    explanation: "Java의 가비지 컬렉션은 JVM에 의해 자동으로 실행됩니다."
                },
                {
                    question: "Java에서 클래스명과 파일명은 반드시 같아야 한다.",
                    type: "ox",
                    correct: true,
                    explanation: "Java에서 public 클래스의 이름과 파일명은 반드시 같아야 합니다."
                },
                {
                    question: "Java는 다중 상속을 지원한다.",
                    type: "ox",
                    correct: false,
                    explanation: "Java는 클래스의 다중 상속을 지원하지 않습니다(인터페이스는 가능)."
                },
                {
                    question: "Java에서 모든 클래스는 Object 클래스를 상속받는다.",
                    type: "ox",
                    correct: true,
                    explanation: "Java에서 모든 클래스는 직간접적으로 Object 클래스를 상속받습니다."
                },
                {
                    question: "Java의 컬렉션 프레임워크에서 List 인터페이스를 구현하지 않는 클래스는?",
                    options: ["ArrayList", "LinkedList", "Vector", "HashSet"],
                    correct: 3,
                    explanation: "HashSet은 Set 인터페이스를 구현하며 List 인터페이스는 구현하지 않습니다."
                },
                {
                    question: "Java에서 문자열을 비교할 때 올바른 방법은?",
                    options: ["str1 == str2", "str1.equals(str2)", "str1.compare(str2)", "str1 = str2"],
                    correct: 1,
                    explanation: "Java에서는 equals() 메소드를 사용하여 문자열 내용을 비교합니다."
                },
                {
                    question: "Java의 가비지 컬렉션에 대한 설명으로 올바른 것은?",
                    options: [
                        "개발자가 직접 메모리를 해제해야 한다",
                        "자동으로 사용하지 않는 객체의 메모리를 회수한다",
                        "C언어의 free() 함수와 동일하다",
                        "프로그램 종료 시에만 실행된다"
                    ],
                    correct: 1,
                    explanation: "Java의 가비지 컬렉션은 더 이상 참조되지 않는 객체의 메모리를 자동으로 회수합니다."
                },
                {
                    question: "Java에서 인터페이스에 대한 설명으로 틀린 것은?",
                    options: [
                        "다중 상속을 지원한다",
                        "모든 메소드는 추상 메소드이다",
                        "인스턴스 변수를 가질 수 있다",
                        "implements 키워드로 구현한다"
                    ],
                    correct: 2,
                    explanation: "인터페이스는 인스턴스 변수를 가질 수 없으며, 상수만 선언할 수 있습니다."
                },
                {
                    question: "Java의 패키지에 대한 설명으로 올바른 것은?",
                    options: [
                        "클래스들을 논리적으로 그룹화한다",
                        "import 문으로 사용한다",
                        "네임스페이스 기능을 제공한다",
                        "위의 모든 설명이 올바르다"
                    ],
                    correct: 3,
                    explanation: "Java의 패키지는 클래스들을 그룹화하고 네임스페이스를 제공하며 import로 사용합니다."
                }
            ]
        };

        // 초기화
        document.addEventListener('DOMContentLoaded', function() {
            loadStats();
            updateStatsDisplay();
        });

        // 통계 로드 (localStorage에서)
        function loadStats() {
            const savedStats = localStorage.getItem('knouExamStats');
            if (savedStats) {
                examStats = JSON.parse(savedStats);
            }
            
            const savedWrongAnswers = localStorage.getItem('knouWrongAnswers');
            if (savedWrongAnswers) {
                wrongAnswersHistory = JSON.parse(savedWrongAnswers);
            }
        }

        // 통계 저장 (localStorage에)
        function saveStats() {
            localStorage.setItem('knouExamStats', JSON.stringify(examStats));
            localStorage.setItem('knouWrongAnswers', JSON.stringify(wrongAnswersHistory));
        }

        // 통계 업데이트
        function updateStatsDisplay() {
            Object.keys(examStats).forEach(subject => {
                const bestElement = document.getElementById(`${subject}-best`);
                const countElement = document.getElementById(`${subject}-count`);
                if (bestElement) bestElement.textContent = examStats[subject].best;
                if (countElement) countElement.textContent = examStats[subject].count;
            });
        }

        // 시험 시작
        function startExam(subject) {
            currentSubject = subject;
            currentQuestionIndex = 0;
            userAnswers = [];
            examStartTime = Date.now();
            examTimeLeft = examTimeLimit;

            // 문제 준비 - 랜덤으로 20문제 선택
            if (subject === 'mixed') {
                currentQuestions = getMixedQuestions();
            } else {
                currentQuestions = [...questionDatabase[subject]];
                shuffleArray(currentQuestions);
                currentQuestions = currentQuestions.slice(0, 20); // 랜덤 20문제 선택
            }

            // 사용자 답안 초기화
            userAnswers = new Array(currentQuestions.length).fill(null);

            showScreen('examScreen');
            displayQuestion();
            startTimer();
        }

        // 혼합 문제 생성
        function getMixedQuestions() {
            const allQuestions = [];
            Object.keys(questionDatabase).forEach(subject => {
                if (subject !== 'mixed') {
                    allQuestions.push(...questionDatabase[subject]);
                }
            });
            shuffleArray(allQuestions);
            return allQuestions.slice(0, 20);
        }

        // 배열 섞기
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // 화면 전환
        function showScreen(screenId) {
            const screens = ['mainScreen', 'examScreen', 'resultScreen', 'wrongAnswerScreen'];
            screens.forEach(screen => {
                document.getElementById(screen).classList.add('hidden');
            });
            document.getElementById(screenId).classList.remove('hidden');
            document.getElementById(screenId).classList.add('fade-in');
        }

        // 문제 표시
        function displayQuestion() {
            const question = currentQuestions[currentQuestionIndex];
            const subjectNames = {
                computer: '💻 컴퓨터의이해',
                ubiquitous: '🌐 유비쿼터스컴퓨팅개론',
                python: '🐍 파이썬프로그래밍기초',
                html: '🌍 HTML5웹프로그래밍',
                java: '☕ Java프로그래밍',
                mixed: '🎯 종합시험'
            };

            document.getElementById('currentSubject').textContent = subjectNames[currentSubject];
            document.getElementById('currentQuestionNum').textContent = currentQuestionIndex + 1;
            document.getElementById('totalQuestions').textContent = currentQuestions.length;

            // 진행률 업데이트
            const progress = ((currentQuestionIndex + 1) / currentQuestions.length) * 100;
            document.getElementById('progressFill').style.width = progress + '%';

            // 문제 텍스트 표시
            let questionText = question.question;
            let codeText = '';
            
            // 코드 블록 분리
            if (questionText.includes('```')) {
                const parts = questionText.split('```');
                questionText = parts[0];
                if (parts.length > 1) {
                    codeText = parts[1].replace(/^python\n/, '').replace(/^javascript\n/, '').replace(/^java\n/, '');
                    if (parts.length > 2) {
                        questionText += parts[2];
                    }
                }
            }

            document.getElementById('questionText').textContent = questionText;
            
            if (codeText) {
                document.getElementById('questionCode').style.display = 'block';
                document.getElementById('questionCode').textContent = codeText;
            } else {
                document.getElementById('questionCode').style.display = 'none';
            }

            // 선택지 표시
            const optionsContainer = document.getElementById('optionsContainer');
            optionsContainer.innerHTML = '';

            if (question.type === 'ox') {
                // O/X 문제
                const options = ['O (참)', 'X (거짓)'];
                options.forEach((option, index) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'option';
                    optionDiv.textContent = option;
                    optionDiv.onclick = () => selectAnswer(index === 0);
                    
                    if (userAnswers[currentQuestionIndex] === (index === 0)) {
                        optionDiv.classList.add('selected');
                    }
                    
                    optionsContainer.appendChild(optionDiv);
                });
            } else {
                // 객관식 문제
                question.options.forEach((option, index) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'option';
                    optionDiv.textContent = `${String.fromCharCode(65 + index)}. ${option}`;
                    optionDiv.onclick = () => selectAnswer(index);
                    
                    if (userAnswers[currentQuestionIndex] === index) {
                        optionDiv.classList.add('selected');
                    }
                    
                    optionsContainer.appendChild(optionDiv);
                });
            }

            // 버튼 상태 업데이트
            updateNavigationButtons();
        }

        // 답안 선택
        function selectAnswer(answer) {
            userAnswers[currentQuestionIndex] = answer;
            
            // 선택 표시 업데이트
            const options = document.querySelectorAll('.option');
            options.forEach((option, index) => {
                option.classList.remove('selected');
                const question = currentQuestions[currentQuestionIndex];
                if (question.type === 'ox') {
                    if ((index === 0 && answer === true) || (index === 1 && answer === false)) {
                        option.classList.add('selected');
                    }
                } else {
                    if (index === answer) {
                        option.classList.add('selected');
                    }
                }
            });
        }

        // 네비게이션 버튼 업데이트
        function updateNavigationButtons() {
            const nextBtn = document.getElementById('nextBtn');
            if (currentQuestionIndex === currentQuestions.length - 1) {
                nextBtn.textContent = '완료';
                nextBtn.onclick = finishExam;
            } else {
                nextBtn.textContent = '다음 ▶';
                nextBtn.onclick = nextQuestion;
            }
        }

        // 다음 문제
        function nextQuestion() {
            if (currentQuestionIndex < currentQuestions.length - 1) {
                currentQuestionIndex++;
                displayQuestion();
            }
        }

        // 이전 문제
        function previousQuestion() {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                displayQuestion();
            }
        }

        // 타이머 시작
        function startTimer() {
            examTimer = setInterval(() => {
                examTimeLeft--;
                updateTimerDisplay();
                
                if (examTimeLeft <= 0) {
                    finishExam();
                }
            }, 1000);
        }

        // 타이머 표시 업데이트
        function updateTimerDisplay() {
            const minutes = Math.floor(examTimeLeft / 60);
            const seconds = examTimeLeft % 60;
            document.getElementById('timer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // 시험 종료
        function finishExam() {
            if (examTimer) {
                clearInterval(examTimer);
            }

            const score = calculateScore();
            const timeUsed = Math.floor((Date.now() - examStartTime) / 1000);
            
            // 통계 업데이트
            examStats[currentSubject].count++;
            if (score > examStats[currentSubject].best) {
                examStats[currentSubject].best = score;
            }

            // 틀린 문제 저장
            saveWrongAnswers();

            // 데이터 저장
            saveStats();

            // 결과 화면 표시
            showResults(score, timeUsed);
            showScreen('resultScreen');
            updateStatsDisplay();
        }

        // 점수 계산
        function calculateScore() {
            let correct = 0;
            currentQuestions.forEach((question, index) => {
                if (userAnswers[index] !== null) {
                    if (question.type === 'ox') {
                        if (userAnswers[index] === question.correct) {
                            correct++;
                        }
                    } else {
                        if (userAnswers[index] === question.correct) {
                            correct++;
                        }
                    }
                }
            });
            return Math.round((correct / currentQuestions.length) * 100);
        }

        // 틀린 문제 저장
        function saveWrongAnswers() {
            currentQuestions.forEach((question, index) => {
                let isCorrect = false;
                if (userAnswers[index] !== null) {
                    if (question.type === 'ox') {
                        isCorrect = userAnswers[index] === question.correct;
                    } else {
                        isCorrect = userAnswers[index] === question.correct;
                    }
                }

                if (!isCorrect) {
                    const wrongAnswer = {
                        subject: currentSubject,
                        question: question,
                        userAnswer: userAnswers[index],
                        timestamp: new Date().toLocaleString()
                    };
                    
                    // 중복 제거
                    const exists = wrongAnswersHistory.some(item => 
                        item.question.question === question.question
                    );
                    if (!exists) {
                        wrongAnswersHistory.push(wrongAnswer);
                    }
                }
            });
        }

        // 결과 표시
        function showResults(score, timeUsed) {
            const correct = Math.round((score / 100) * currentQuestions.length);
            const incorrect = currentQuestions.length - correct;
            const timeUsedMinutes = Math.floor(timeUsed / 60);

            document.getElementById('finalScore').textContent = score + '점';
            document.getElementById('correctCount').textContent = correct;
            document.getElementById('incorrectCount').textContent = incorrect;
            document.getElementById('accuracy').textContent = score + '%';
            document.getElementById('timeUsed').textContent = timeUsedMinutes + '분';

            // 틀린 문제 표시
            if (incorrect > 0) {
                displayWrongAnswersInResult();
            } else {
                document.getElementById('wrongAnswersContainer').style.display = 'none';
            }
        }

        // 결과 화면에서 틀린 문제 표시
        function displayWrongAnswersInResult() {
            const container = document.getElementById('wrongAnswersContainer');
            const list = document.getElementById('wrongQuestionsList');
            
            list.innerHTML = '';
            
            currentQuestions.forEach((question, index) => {
                let isCorrect = false;
                if (userAnswers[index] !== null) {
                    if (question.type === 'ox') {
                        isCorrect = userAnswers[index] === question.correct;
                    } else {
                        isCorrect = userAnswers[index] === question.correct;
                    }
                }

                if (!isCorrect) {
                    const wrongDiv = document.createElement('div');
                    wrongDiv.className = 'wrong-question';
                    
                    let userAnswerText = '무응답';
                    if (userAnswers[index] !== null) {
                        if (question.type === 'ox') {
                            userAnswerText = userAnswers[index] ? 'O' : 'X';
                        } else {
                            userAnswerText = String.fromCharCode(65 + userAnswers[index]);
                        }
                    }

                    let correctAnswerText;
                    if (question.type === 'ox') {
                        correctAnswerText = question.correct ? 'O' : 'X';
                    } else {
                        correctAnswerText = String.fromCharCode(65 + question.correct);
                    }

                    wrongDiv.innerHTML = `
                        <strong>문제 ${index + 1}:</strong> ${question.question}<br>
                        <strong>선택한 답:</strong> ${userAnswerText}<br>
                        <strong>정답:</strong> ${correctAnswerText}<br>
                        <strong>해설:</strong> ${question.explanation}
                    `;
                    
                    list.appendChild(wrongDiv);
                }
            });
            
            container.style.display = 'block';
        }

        // 시험 재시작
        function restartExam() {
            startExam(currentSubject);
        }

        // 틀린 문제 복습
        function reviewWrongAnswers() {
            // 현재 시험에서 틀린 문제들만 추출
            const wrongQuestions = [];
            currentQuestions.forEach((question, index) => {
                let isCorrect = false;
                if (userAnswers[index] !== null) {
                    if (question.type === 'ox') {
                        isCorrect = userAnswers[index] === question.correct;
                    } else {
                        isCorrect = userAnswers[index] === question.correct;
                    }
                }
                if (!isCorrect) {
                    wrongQuestions.push(question);
                }
            });

            if (wrongQuestions.length === 0) {
                alert('틀린 문제가 없습니다!');
                return;
            }

            // 틀린 문제로 새 시험 시작
            currentQuestions = wrongQuestions;
            currentQuestionIndex = 0;
            userAnswers = new Array(currentQuestions.length).fill(null);
            examStartTime = Date.now();
            examTimeLeft = Math.min(currentQuestions.length * 60, 1800); // 문제당 1분, 최대 30분

            showScreen('examScreen');
            displayQuestion();
            startTimer();
        }

        // 홈으로
        function goHome() {
            if (examTimer) {
                clearInterval(examTimer);
            }
            showScreen('mainScreen');
        }

        // 오답노트 보기
        function showWrongAnswers() {
            const container = document.getElementById('wrongAnswersList');
            container.innerHTML = '';

            if (wrongAnswersHistory.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #718096; margin: 50px 0;">저장된 오답이 없습니다.</p>';
            } else {
                const subjectNames = {
                    computer: '💻 컴퓨터의이해',
                    ubiquitous: '🌐 유비쿼터스컴퓨팅개론',
                    python: '🐍 파이썬프로그래밍기초',
                    html: '🌍 HTML5웹프로그래밍',
                    java: '☕ Java프로그래밍',
                    mixed: '🎯 종합시험'
                };

                wrongAnswersHistory.forEach((item, index) => {
                    const wrongDiv = document.createElement('div');
                    wrongDiv.className = 'wrong-question';
                    
                    let userAnswerText = '무응답';
                    if (item.userAnswer !== null) {
                        if (item.question.type === 'ox') {
                            userAnswerText = item.userAnswer ? 'O' : 'X';
                        } else {
                            userAnswerText = String.fromCharCode(65 + item.userAnswer);
                        }
                    }

                    let correctAnswerText;
                    if (item.question.type === 'ox') {
                        correctAnswerText = item.question.correct ? 'O' : 'X';
                    } else {
                        correctAnswerText = String.fromCharCode(65 + item.question.correct);
                    }

                    wrongDiv.innerHTML = `
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <strong>${subjectNames[item.subject]}</strong>
                            <small>${item.timestamp}</small>
                        </div>
                        <strong>문제:</strong> ${item.question.question}<br>
                        <strong>선택한 답:</strong> ${userAnswerText}<br>
                        <strong>정답:</strong> ${correctAnswerText}<br>
                        <strong>해설:</strong> ${item.question.explanation}
                    `;
                    
                    container.appendChild(wrongDiv);
                });
            }

            showScreen('wrongAnswerScreen');
        }

        // 데이터 초기화 확인
        function resetAllData() {
            showConfirmModal('데이터 초기화', '모든 통계와 오답 데이터를 삭제하시겠습니까?', () => {
                // 통계 초기화
                Object.keys(examStats).forEach(subject => {
                    examStats[subject] = { best: 0, count: 0 };
                });
                
                // 오답 히스토리 초기화
                wrongAnswersHistory = [];
                
                // 데이터 저장
                saveStats();
                
                updateStatsDisplay();
                alert('데이터가 초기화되었습니다.');
            });
        }

        // 확인 모달 표시
        function showConfirmModal(title, message, callback) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').textContent = message;
            confirmCallback = callback;
            document.getElementById('confirmModal').style.display = 'block';
        }

        // 모달 닫기
        function closeModal() {
            document.getElementById('confirmModal').style.display = 'none';
            confirmCallback = null;
        }

        // 확인 액션 실행
        function confirmAction() {
            if (confirmCallback) {
                confirmCallback();
            }
            closeModal();
        }

        // 모달 외부 클릭 시 닫기
        window.onclick = function(event) {
            const modal = document.getElementById('confirmModal');
            if (event.target === modal) {
                closeModal();
            }
        }
    </script>
</body>
</html>
